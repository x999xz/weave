// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';



export class Hotkey_ implements flatbuffers.IUnpackableObject<Hotkey_T> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Hotkey_ {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsHotkey_(bb:flatbuffers.ByteBuffer, obj?:Hotkey_):Hotkey_ {
  return (obj || new Hotkey_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsHotkey_(bb:flatbuffers.ByteBuffer, obj?:Hotkey_):Hotkey_ {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Hotkey_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

hash():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_hash(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

key():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

mutate_key(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
}

mode():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

mutate_mode(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
}

visible():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_visible(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 10);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

type():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

mutate_type(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 12);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
}

nameVisual(index: number):string
nameVisual(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
nameVisual(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

nameVisualLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

name(index: number):string
name(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
name(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

nameLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

value(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;
}

valueLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

valueArray():Float64Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startHotkey_(builder:flatbuffers.Builder) {
  builder.startObject(8);
}

static addHash(builder:flatbuffers.Builder, hash:bigint) {
  builder.addFieldInt64(0, hash, BigInt('0'));
}

static addKey(builder:flatbuffers.Builder, key:number) {
  builder.addFieldInt32(1, key, 0);
}

static addMode(builder:flatbuffers.Builder, mode:number) {
  builder.addFieldInt32(2, mode, 0);
}

static addVisible(builder:flatbuffers.Builder, visible:boolean) {
  builder.addFieldInt8(3, +visible, +false);
}

static addType(builder:flatbuffers.Builder, type:number) {
  builder.addFieldInt32(4, type, 0);
}

static addNameVisual(builder:flatbuffers.Builder, nameVisualOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, nameVisualOffset, 0);
}

static createNameVisualVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startNameVisualVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, nameOffset, 0);
}

static createNameVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startNameVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, valueOffset, 0);
}

static createValueVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createValueVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createValueVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat64(data[i]!);
  }
  return builder.endVector();
}

static startValueVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static endHotkey_(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createHotkey_(builder:flatbuffers.Builder, hash:bigint, key:number, mode:number, visible:boolean, type:number, nameVisualOffset:flatbuffers.Offset, nameOffset:flatbuffers.Offset, valueOffset:flatbuffers.Offset):flatbuffers.Offset {
  Hotkey_.startHotkey_(builder);
  Hotkey_.addHash(builder, hash);
  Hotkey_.addKey(builder, key);
  Hotkey_.addMode(builder, mode);
  Hotkey_.addVisible(builder, visible);
  Hotkey_.addType(builder, type);
  Hotkey_.addNameVisual(builder, nameVisualOffset);
  Hotkey_.addName(builder, nameOffset);
  Hotkey_.addValue(builder, valueOffset);
  return Hotkey_.endHotkey_(builder);
}

unpack(): Hotkey_T {
  return new Hotkey_T(
    this.hash(),
    this.key(),
    this.mode(),
    this.visible(),
    this.type(),
    this.bb!.createScalarList<string>(this.nameVisual.bind(this), this.nameVisualLength()),
    this.bb!.createScalarList<string>(this.name.bind(this), this.nameLength()),
    this.bb!.createScalarList<number>(this.value.bind(this), this.valueLength())
  );
}


unpackTo(_o: Hotkey_T): void {
  _o.hash = this.hash();
  _o.key = this.key();
  _o.mode = this.mode();
  _o.visible = this.visible();
  _o.type = this.type();
  _o.nameVisual = this.bb!.createScalarList<string>(this.nameVisual.bind(this), this.nameVisualLength());
  _o.name = this.bb!.createScalarList<string>(this.name.bind(this), this.nameLength());
  _o.value = this.bb!.createScalarList<number>(this.value.bind(this), this.valueLength());
}
}

export class Hotkey_T implements flatbuffers.IGeneratedObject {
constructor(
  public hash: bigint = BigInt('0'),
  public key: number = 0,
  public mode: number = 0,
  public visible: boolean = false,
  public type: number = 0,
  public nameVisual: (string)[] = [],
  public name: (string)[] = [],
  public value: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const nameVisual = Hotkey_.createNameVisualVector(builder, builder.createObjectOffsetList(this.nameVisual));
  const name = Hotkey_.createNameVector(builder, builder.createObjectOffsetList(this.name));
  const value = Hotkey_.createValueVector(builder, this.value);

  return Hotkey_.createHotkey_(builder,
    this.hash,
    this.key,
    this.mode,
    this.visible,
    this.type,
    nameVisual,
    name,
    value
  );
}
}
