// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';



export class antiaim implements flatbuffers.IUnpackableObject<antiaimT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):antiaim {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsantiaim(bb:flatbuffers.ByteBuffer, obj?:antiaim):antiaim {
  return (obj || new antiaim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsantiaim(bb:flatbuffers.ByteBuffer, obj?:antiaim):antiaim {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new antiaim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

enabled():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_enabled(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

atTarget():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_at_target(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

pitch():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

mutate_pitch(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
}

yaw():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

mutate_yaw(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 10);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
}

yawOffset():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

mutate_yaw_offset(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 12);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
}

jitter():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

mutate_jitter(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 14);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
}

static startantiaim(builder:flatbuffers.Builder) {
  builder.startObject(6);
}

static addEnabled(builder:flatbuffers.Builder, enabled:boolean) {
  builder.addFieldInt8(0, +enabled, +false);
}

static addAtTarget(builder:flatbuffers.Builder, atTarget:boolean) {
  builder.addFieldInt8(1, +atTarget, +false);
}

static addPitch(builder:flatbuffers.Builder, pitch:number) {
  builder.addFieldInt32(2, pitch, 0);
}

static addYaw(builder:flatbuffers.Builder, yaw:number) {
  builder.addFieldInt32(3, yaw, 0);
}

static addYawOffset(builder:flatbuffers.Builder, yawOffset:number) {
  builder.addFieldInt32(4, yawOffset, 0);
}

static addJitter(builder:flatbuffers.Builder, jitter:number) {
  builder.addFieldInt32(5, jitter, 0);
}

static endantiaim(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createantiaim(builder:flatbuffers.Builder, enabled:boolean, atTarget:boolean, pitch:number, yaw:number, yawOffset:number, jitter:number):flatbuffers.Offset {
  antiaim.startantiaim(builder);
  antiaim.addEnabled(builder, enabled);
  antiaim.addAtTarget(builder, atTarget);
  antiaim.addPitch(builder, pitch);
  antiaim.addYaw(builder, yaw);
  antiaim.addYawOffset(builder, yawOffset);
  antiaim.addJitter(builder, jitter);
  return antiaim.endantiaim(builder);
}

unpack(): antiaimT {
  return new antiaimT(
    this.enabled(),
    this.atTarget(),
    this.pitch(),
    this.yaw(),
    this.yawOffset(),
    this.jitter()
  );
}


unpackTo(_o: antiaimT): void {
  _o.enabled = this.enabled();
  _o.atTarget = this.atTarget();
  _o.pitch = this.pitch();
  _o.yaw = this.yaw();
  _o.yawOffset = this.yawOffset();
  _o.jitter = this.jitter();
}
}

export class antiaimT implements flatbuffers.IGeneratedObject {
constructor(
  public enabled: boolean = false,
  public atTarget: boolean = false,
  public pitch: number = 0,
  public yaw: number = 0,
  public yawOffset: number = 0,
  public jitter: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return antiaim.createantiaim(builder,
    this.enabled,
    this.atTarget,
    this.pitch,
    this.yaw,
    this.yawOffset,
    this.jitter
  );
}
}
