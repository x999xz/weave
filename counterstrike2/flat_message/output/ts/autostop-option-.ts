// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';



export class autostop_option_ implements flatbuffers.IUnpackableObject<autostop_option_T> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):autostop_option_ {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsautostop_option_(bb:flatbuffers.ByteBuffer, obj?:autostop_option_):autostop_option_ {
  return (obj || new autostop_option_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsautostop_option_(bb:flatbuffers.ByteBuffer, obj?:autostop_option_):autostop_option_ {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new autostop_option_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

mBeetwenShot():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_m_beetwen_shot(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

mAccuracy():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_m_accuracy(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

mMolotovIgnore():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_m_molotov_ignore(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

static startautostop_option_(builder:flatbuffers.Builder) {
  builder.startObject(3);
}

static addMBeetwenShot(builder:flatbuffers.Builder, mBeetwenShot:boolean) {
  builder.addFieldInt8(0, +mBeetwenShot, +false);
}

static addMAccuracy(builder:flatbuffers.Builder, mAccuracy:boolean) {
  builder.addFieldInt8(1, +mAccuracy, +false);
}

static addMMolotovIgnore(builder:flatbuffers.Builder, mMolotovIgnore:boolean) {
  builder.addFieldInt8(2, +mMolotovIgnore, +false);
}

static endautostop_option_(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createautostop_option_(builder:flatbuffers.Builder, mBeetwenShot:boolean, mAccuracy:boolean, mMolotovIgnore:boolean):flatbuffers.Offset {
  autostop_option_.startautostop_option_(builder);
  autostop_option_.addMBeetwenShot(builder, mBeetwenShot);
  autostop_option_.addMAccuracy(builder, mAccuracy);
  autostop_option_.addMMolotovIgnore(builder, mMolotovIgnore);
  return autostop_option_.endautostop_option_(builder);
}

unpack(): autostop_option_T {
  return new autostop_option_T(
    this.mBeetwenShot(),
    this.mAccuracy(),
    this.mMolotovIgnore()
  );
}


unpackTo(_o: autostop_option_T): void {
  _o.mBeetwenShot = this.mBeetwenShot();
  _o.mAccuracy = this.mAccuracy();
  _o.mMolotovIgnore = this.mMolotovIgnore();
}
}

export class autostop_option_T implements flatbuffers.IGeneratedObject {
constructor(
  public mBeetwenShot: boolean = false,
  public mAccuracy: boolean = false,
  public mMolotovIgnore: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return autostop_option_.createautostop_option_(builder,
    this.mBeetwenShot,
    this.mAccuracy,
    this.mMolotovIgnore
  );
}
}
