// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';



export class flags_ implements flatbuffers.IUnpackableObject<flags_T> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):flags_ {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsflags_(bb:flatbuffers.ByteBuffer, obj?:flags_):flags_ {
  return (obj || new flags_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsflags_(bb:flatbuffers.ByteBuffer, obj?:flags_):flags_ {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new flags_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

bomb():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_bomb(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

kits():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_kits(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

armor():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_armor(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

flashed():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_flashed(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 10);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

zeus():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_zeus(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 12);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

defuser():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_defuser(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 14);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

static startflags_(builder:flatbuffers.Builder) {
  builder.startObject(6);
}

static addBomb(builder:flatbuffers.Builder, bomb:boolean) {
  builder.addFieldInt8(0, +bomb, +false);
}

static addKits(builder:flatbuffers.Builder, kits:boolean) {
  builder.addFieldInt8(1, +kits, +false);
}

static addArmor(builder:flatbuffers.Builder, armor:boolean) {
  builder.addFieldInt8(2, +armor, +false);
}

static addFlashed(builder:flatbuffers.Builder, flashed:boolean) {
  builder.addFieldInt8(3, +flashed, +false);
}

static addZeus(builder:flatbuffers.Builder, zeus:boolean) {
  builder.addFieldInt8(4, +zeus, +false);
}

static addDefuser(builder:flatbuffers.Builder, defuser:boolean) {
  builder.addFieldInt8(5, +defuser, +false);
}

static endflags_(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createflags_(builder:flatbuffers.Builder, bomb:boolean, kits:boolean, armor:boolean, flashed:boolean, zeus:boolean, defuser:boolean):flatbuffers.Offset {
  flags_.startflags_(builder);
  flags_.addBomb(builder, bomb);
  flags_.addKits(builder, kits);
  flags_.addArmor(builder, armor);
  flags_.addFlashed(builder, flashed);
  flags_.addZeus(builder, zeus);
  flags_.addDefuser(builder, defuser);
  return flags_.endflags_(builder);
}

unpack(): flags_T {
  return new flags_T(
    this.bomb(),
    this.kits(),
    this.armor(),
    this.flashed(),
    this.zeus(),
    this.defuser()
  );
}


unpackTo(_o: flags_T): void {
  _o.bomb = this.bomb();
  _o.kits = this.kits();
  _o.armor = this.armor();
  _o.flashed = this.flashed();
  _o.zeus = this.zeus();
  _o.defuser = this.defuser();
}
}

export class flags_T implements flatbuffers.IGeneratedObject {
constructor(
  public bomb: boolean = false,
  public kits: boolean = false,
  public armor: boolean = false,
  public flashed: boolean = false,
  public zeus: boolean = false,
  public defuser: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return flags_.createflags_(builder,
    this.bomb,
    this.kits,
    this.armor,
    this.flashed,
    this.zeus,
    this.defuser
  );
}
}
