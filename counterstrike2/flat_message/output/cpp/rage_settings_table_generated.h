// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RAGESETTINGSTABLE_H_
#define FLATBUFFERS_GENERATED_RAGESETTINGSTABLE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct hitboxes_;
struct hitboxes_Builder;
struct hitboxes_T;

struct autostop_option_;
struct autostop_option_Builder;
struct autostop_option_T;

struct rage_global_settings;
struct rage_global_settingsBuilder;
struct rage_global_settingsT;

struct rage_settings;
struct rage_settingsBuilder;
struct rage_settingsT;

bool operator==(const hitboxes_T &lhs, const hitboxes_T &rhs);
bool operator!=(const hitboxes_T &lhs, const hitboxes_T &rhs);
bool operator==(const autostop_option_T &lhs, const autostop_option_T &rhs);
bool operator!=(const autostop_option_T &lhs, const autostop_option_T &rhs);
bool operator==(const rage_global_settingsT &lhs, const rage_global_settingsT &rhs);
bool operator!=(const rage_global_settingsT &lhs, const rage_global_settingsT &rhs);
bool operator==(const rage_settingsT &lhs, const rage_settingsT &rhs);
bool operator!=(const rage_settingsT &lhs, const rage_settingsT &rhs);

inline const ::flatbuffers::TypeTable *hitboxes_TypeTable();

inline const ::flatbuffers::TypeTable *autostop_option_TypeTable();

inline const ::flatbuffers::TypeTable *rage_global_settingsTypeTable();

inline const ::flatbuffers::TypeTable *rage_settingsTypeTable();

struct hitboxes_T : public ::flatbuffers::NativeTable {
  typedef hitboxes_ TableType;
  bool m_head = false;
  bool m_chest = false;
  bool m_stomach = false;
  bool m_arms = false;
  bool m_legs = false;
  bool m_foot = false;
};

struct hitboxes_ FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef hitboxes_T NativeTableType;
  typedef hitboxes_Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return hitboxes_TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_HEAD = 4,
    VT_M_CHEST = 6,
    VT_M_STOMACH = 8,
    VT_M_ARMS = 10,
    VT_M_LEGS = 12,
    VT_M_FOOT = 14
  };
  bool m_head() const {
    return GetField<uint8_t>(VT_M_HEAD, 0) != 0;
  }
  bool mutate_m_head(bool _m_head = 0) {
    return SetField<uint8_t>(VT_M_HEAD, static_cast<uint8_t>(_m_head), 0);
  }
  bool m_chest() const {
    return GetField<uint8_t>(VT_M_CHEST, 0) != 0;
  }
  bool mutate_m_chest(bool _m_chest = 0) {
    return SetField<uint8_t>(VT_M_CHEST, static_cast<uint8_t>(_m_chest), 0);
  }
  bool m_stomach() const {
    return GetField<uint8_t>(VT_M_STOMACH, 0) != 0;
  }
  bool mutate_m_stomach(bool _m_stomach = 0) {
    return SetField<uint8_t>(VT_M_STOMACH, static_cast<uint8_t>(_m_stomach), 0);
  }
  bool m_arms() const {
    return GetField<uint8_t>(VT_M_ARMS, 0) != 0;
  }
  bool mutate_m_arms(bool _m_arms = 0) {
    return SetField<uint8_t>(VT_M_ARMS, static_cast<uint8_t>(_m_arms), 0);
  }
  bool m_legs() const {
    return GetField<uint8_t>(VT_M_LEGS, 0) != 0;
  }
  bool mutate_m_legs(bool _m_legs = 0) {
    return SetField<uint8_t>(VT_M_LEGS, static_cast<uint8_t>(_m_legs), 0);
  }
  bool m_foot() const {
    return GetField<uint8_t>(VT_M_FOOT, 0) != 0;
  }
  bool mutate_m_foot(bool _m_foot = 0) {
    return SetField<uint8_t>(VT_M_FOOT, static_cast<uint8_t>(_m_foot), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_M_HEAD, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_CHEST, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_STOMACH, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_ARMS, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_LEGS, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_FOOT, 1) &&
           verifier.EndTable();
  }
  hitboxes_T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(hitboxes_T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<hitboxes_> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const hitboxes_T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct hitboxes_Builder {
  typedef hitboxes_ Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_m_head(bool m_head) {
    fbb_.AddElement<uint8_t>(hitboxes_::VT_M_HEAD, static_cast<uint8_t>(m_head), 0);
  }
  void add_m_chest(bool m_chest) {
    fbb_.AddElement<uint8_t>(hitboxes_::VT_M_CHEST, static_cast<uint8_t>(m_chest), 0);
  }
  void add_m_stomach(bool m_stomach) {
    fbb_.AddElement<uint8_t>(hitboxes_::VT_M_STOMACH, static_cast<uint8_t>(m_stomach), 0);
  }
  void add_m_arms(bool m_arms) {
    fbb_.AddElement<uint8_t>(hitboxes_::VT_M_ARMS, static_cast<uint8_t>(m_arms), 0);
  }
  void add_m_legs(bool m_legs) {
    fbb_.AddElement<uint8_t>(hitboxes_::VT_M_LEGS, static_cast<uint8_t>(m_legs), 0);
  }
  void add_m_foot(bool m_foot) {
    fbb_.AddElement<uint8_t>(hitboxes_::VT_M_FOOT, static_cast<uint8_t>(m_foot), 0);
  }
  explicit hitboxes_Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<hitboxes_> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<hitboxes_>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<hitboxes_> Createhitboxes_(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool m_head = false,
    bool m_chest = false,
    bool m_stomach = false,
    bool m_arms = false,
    bool m_legs = false,
    bool m_foot = false) {
  hitboxes_Builder builder_(_fbb);
  builder_.add_m_foot(m_foot);
  builder_.add_m_legs(m_legs);
  builder_.add_m_arms(m_arms);
  builder_.add_m_stomach(m_stomach);
  builder_.add_m_chest(m_chest);
  builder_.add_m_head(m_head);
  return builder_.Finish();
}

::flatbuffers::Offset<hitboxes_> Createhitboxes_(::flatbuffers::FlatBufferBuilder &_fbb, const hitboxes_T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct autostop_option_T : public ::flatbuffers::NativeTable {
  typedef autostop_option_ TableType;
  bool m_beetwen_shot = false;
  bool m_accuracy = false;
  bool m_molotov_ignore = false;
};

struct autostop_option_ FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef autostop_option_T NativeTableType;
  typedef autostop_option_Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return autostop_option_TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_BEETWEN_SHOT = 4,
    VT_M_ACCURACY = 6,
    VT_M_MOLOTOV_IGNORE = 8
  };
  bool m_beetwen_shot() const {
    return GetField<uint8_t>(VT_M_BEETWEN_SHOT, 0) != 0;
  }
  bool mutate_m_beetwen_shot(bool _m_beetwen_shot = 0) {
    return SetField<uint8_t>(VT_M_BEETWEN_SHOT, static_cast<uint8_t>(_m_beetwen_shot), 0);
  }
  bool m_accuracy() const {
    return GetField<uint8_t>(VT_M_ACCURACY, 0) != 0;
  }
  bool mutate_m_accuracy(bool _m_accuracy = 0) {
    return SetField<uint8_t>(VT_M_ACCURACY, static_cast<uint8_t>(_m_accuracy), 0);
  }
  bool m_molotov_ignore() const {
    return GetField<uint8_t>(VT_M_MOLOTOV_IGNORE, 0) != 0;
  }
  bool mutate_m_molotov_ignore(bool _m_molotov_ignore = 0) {
    return SetField<uint8_t>(VT_M_MOLOTOV_IGNORE, static_cast<uint8_t>(_m_molotov_ignore), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_M_BEETWEN_SHOT, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_ACCURACY, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_MOLOTOV_IGNORE, 1) &&
           verifier.EndTable();
  }
  autostop_option_T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(autostop_option_T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<autostop_option_> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const autostop_option_T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct autostop_option_Builder {
  typedef autostop_option_ Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_m_beetwen_shot(bool m_beetwen_shot) {
    fbb_.AddElement<uint8_t>(autostop_option_::VT_M_BEETWEN_SHOT, static_cast<uint8_t>(m_beetwen_shot), 0);
  }
  void add_m_accuracy(bool m_accuracy) {
    fbb_.AddElement<uint8_t>(autostop_option_::VT_M_ACCURACY, static_cast<uint8_t>(m_accuracy), 0);
  }
  void add_m_molotov_ignore(bool m_molotov_ignore) {
    fbb_.AddElement<uint8_t>(autostop_option_::VT_M_MOLOTOV_IGNORE, static_cast<uint8_t>(m_molotov_ignore), 0);
  }
  explicit autostop_option_Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<autostop_option_> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<autostop_option_>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<autostop_option_> Createautostop_option_(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool m_beetwen_shot = false,
    bool m_accuracy = false,
    bool m_molotov_ignore = false) {
  autostop_option_Builder builder_(_fbb);
  builder_.add_m_molotov_ignore(m_molotov_ignore);
  builder_.add_m_accuracy(m_accuracy);
  builder_.add_m_beetwen_shot(m_beetwen_shot);
  return builder_.Finish();
}

::flatbuffers::Offset<autostop_option_> Createautostop_option_(::flatbuffers::FlatBufferBuilder &_fbb, const autostop_option_T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct rage_global_settingsT : public ::flatbuffers::NativeTable {
  typedef rage_global_settings TableType;
  bool m_enabled = false;
  bool m_auto_fire = false;
  bool m_auto_scope = false;
  bool m_silent = false;
  bool m_penetration = false;
  bool m_nospread = false;
  bool m_norecoil = false;
  bool m_hideshots = false;
  int32_t backtrack_mode = 0;
};

struct rage_global_settings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef rage_global_settingsT NativeTableType;
  typedef rage_global_settingsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return rage_global_settingsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_ENABLED = 4,
    VT_M_AUTO_FIRE = 6,
    VT_M_AUTO_SCOPE = 8,
    VT_M_SILENT = 10,
    VT_M_PENETRATION = 12,
    VT_M_NOSPREAD = 14,
    VT_M_NORECOIL = 16,
    VT_M_HIDESHOTS = 18,
    VT_BACKTRACK_MODE = 20
  };
  bool m_enabled() const {
    return GetField<uint8_t>(VT_M_ENABLED, 0) != 0;
  }
  bool mutate_m_enabled(bool _m_enabled = 0) {
    return SetField<uint8_t>(VT_M_ENABLED, static_cast<uint8_t>(_m_enabled), 0);
  }
  bool m_auto_fire() const {
    return GetField<uint8_t>(VT_M_AUTO_FIRE, 0) != 0;
  }
  bool mutate_m_auto_fire(bool _m_auto_fire = 0) {
    return SetField<uint8_t>(VT_M_AUTO_FIRE, static_cast<uint8_t>(_m_auto_fire), 0);
  }
  bool m_auto_scope() const {
    return GetField<uint8_t>(VT_M_AUTO_SCOPE, 0) != 0;
  }
  bool mutate_m_auto_scope(bool _m_auto_scope = 0) {
    return SetField<uint8_t>(VT_M_AUTO_SCOPE, static_cast<uint8_t>(_m_auto_scope), 0);
  }
  bool m_silent() const {
    return GetField<uint8_t>(VT_M_SILENT, 0) != 0;
  }
  bool mutate_m_silent(bool _m_silent = 0) {
    return SetField<uint8_t>(VT_M_SILENT, static_cast<uint8_t>(_m_silent), 0);
  }
  bool m_penetration() const {
    return GetField<uint8_t>(VT_M_PENETRATION, 0) != 0;
  }
  bool mutate_m_penetration(bool _m_penetration = 0) {
    return SetField<uint8_t>(VT_M_PENETRATION, static_cast<uint8_t>(_m_penetration), 0);
  }
  bool m_nospread() const {
    return GetField<uint8_t>(VT_M_NOSPREAD, 0) != 0;
  }
  bool mutate_m_nospread(bool _m_nospread = 0) {
    return SetField<uint8_t>(VT_M_NOSPREAD, static_cast<uint8_t>(_m_nospread), 0);
  }
  bool m_norecoil() const {
    return GetField<uint8_t>(VT_M_NORECOIL, 0) != 0;
  }
  bool mutate_m_norecoil(bool _m_norecoil = 0) {
    return SetField<uint8_t>(VT_M_NORECOIL, static_cast<uint8_t>(_m_norecoil), 0);
  }
  bool m_hideshots() const {
    return GetField<uint8_t>(VT_M_HIDESHOTS, 0) != 0;
  }
  bool mutate_m_hideshots(bool _m_hideshots = 0) {
    return SetField<uint8_t>(VT_M_HIDESHOTS, static_cast<uint8_t>(_m_hideshots), 0);
  }
  int32_t backtrack_mode() const {
    return GetField<int32_t>(VT_BACKTRACK_MODE, 0);
  }
  bool mutate_backtrack_mode(int32_t _backtrack_mode = 0) {
    return SetField<int32_t>(VT_BACKTRACK_MODE, _backtrack_mode, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_M_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_AUTO_FIRE, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_AUTO_SCOPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_SILENT, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_PENETRATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_NOSPREAD, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_NORECOIL, 1) &&
           VerifyField<uint8_t>(verifier, VT_M_HIDESHOTS, 1) &&
           VerifyField<int32_t>(verifier, VT_BACKTRACK_MODE, 4) &&
           verifier.EndTable();
  }
  rage_global_settingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(rage_global_settingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<rage_global_settings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const rage_global_settingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct rage_global_settingsBuilder {
  typedef rage_global_settings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_m_enabled(bool m_enabled) {
    fbb_.AddElement<uint8_t>(rage_global_settings::VT_M_ENABLED, static_cast<uint8_t>(m_enabled), 0);
  }
  void add_m_auto_fire(bool m_auto_fire) {
    fbb_.AddElement<uint8_t>(rage_global_settings::VT_M_AUTO_FIRE, static_cast<uint8_t>(m_auto_fire), 0);
  }
  void add_m_auto_scope(bool m_auto_scope) {
    fbb_.AddElement<uint8_t>(rage_global_settings::VT_M_AUTO_SCOPE, static_cast<uint8_t>(m_auto_scope), 0);
  }
  void add_m_silent(bool m_silent) {
    fbb_.AddElement<uint8_t>(rage_global_settings::VT_M_SILENT, static_cast<uint8_t>(m_silent), 0);
  }
  void add_m_penetration(bool m_penetration) {
    fbb_.AddElement<uint8_t>(rage_global_settings::VT_M_PENETRATION, static_cast<uint8_t>(m_penetration), 0);
  }
  void add_m_nospread(bool m_nospread) {
    fbb_.AddElement<uint8_t>(rage_global_settings::VT_M_NOSPREAD, static_cast<uint8_t>(m_nospread), 0);
  }
  void add_m_norecoil(bool m_norecoil) {
    fbb_.AddElement<uint8_t>(rage_global_settings::VT_M_NORECOIL, static_cast<uint8_t>(m_norecoil), 0);
  }
  void add_m_hideshots(bool m_hideshots) {
    fbb_.AddElement<uint8_t>(rage_global_settings::VT_M_HIDESHOTS, static_cast<uint8_t>(m_hideshots), 0);
  }
  void add_backtrack_mode(int32_t backtrack_mode) {
    fbb_.AddElement<int32_t>(rage_global_settings::VT_BACKTRACK_MODE, backtrack_mode, 0);
  }
  explicit rage_global_settingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<rage_global_settings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<rage_global_settings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<rage_global_settings> Createrage_global_settings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool m_enabled = false,
    bool m_auto_fire = false,
    bool m_auto_scope = false,
    bool m_silent = false,
    bool m_penetration = false,
    bool m_nospread = false,
    bool m_norecoil = false,
    bool m_hideshots = false,
    int32_t backtrack_mode = 0) {
  rage_global_settingsBuilder builder_(_fbb);
  builder_.add_backtrack_mode(backtrack_mode);
  builder_.add_m_hideshots(m_hideshots);
  builder_.add_m_norecoil(m_norecoil);
  builder_.add_m_nospread(m_nospread);
  builder_.add_m_penetration(m_penetration);
  builder_.add_m_silent(m_silent);
  builder_.add_m_auto_scope(m_auto_scope);
  builder_.add_m_auto_fire(m_auto_fire);
  builder_.add_m_enabled(m_enabled);
  return builder_.Finish();
}

::flatbuffers::Offset<rage_global_settings> Createrage_global_settings(::flatbuffers::FlatBufferBuilder &_fbb, const rage_global_settingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct rage_settingsT : public ::flatbuffers::NativeTable {
  typedef rage_settings TableType;
  int32_t m_index = 0;
  int32_t m_group = 0;
  float test = 0.0f;
  std::string name{};
  std::unique_ptr<hitboxes_T> hitboxes{};
  std::unique_ptr<hitboxes_T> multipoints{};
  bool autostop = false;
  std::unique_ptr<autostop_option_T> autostop_option{};
  int32_t hitchance_amount = 0;
  int32_t point_scale = 0;
  int32_t damage = 0;
  rage_settingsT() = default;
  rage_settingsT(const rage_settingsT &o);
  rage_settingsT(rage_settingsT&&) FLATBUFFERS_NOEXCEPT = default;
  rage_settingsT &operator=(rage_settingsT o) FLATBUFFERS_NOEXCEPT;
};

struct rage_settings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef rage_settingsT NativeTableType;
  typedef rage_settingsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return rage_settingsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_INDEX = 4,
    VT_M_GROUP = 6,
    VT_TEST = 8,
    VT_NAME = 10,
    VT_HITBOXES = 12,
    VT_MULTIPOINTS = 14,
    VT_AUTOSTOP = 16,
    VT_AUTOSTOP_OPTION = 18,
    VT_HITCHANCE_AMOUNT = 20,
    VT_POINT_SCALE = 22,
    VT_DAMAGE = 24
  };
  int32_t m_index() const {
    return GetField<int32_t>(VT_M_INDEX, 0);
  }
  bool mutate_m_index(int32_t _m_index = 0) {
    return SetField<int32_t>(VT_M_INDEX, _m_index, 0);
  }
  int32_t m_group() const {
    return GetField<int32_t>(VT_M_GROUP, 0);
  }
  bool mutate_m_group(int32_t _m_group = 0) {
    return SetField<int32_t>(VT_M_GROUP, _m_group, 0);
  }
  float test() const {
    return GetField<float>(VT_TEST, 0.0f);
  }
  bool mutate_test(float _test = 0.0f) {
    return SetField<float>(VT_TEST, _test, 0.0f);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const hitboxes_ *hitboxes() const {
    return GetPointer<const hitboxes_ *>(VT_HITBOXES);
  }
  hitboxes_ *mutable_hitboxes() {
    return GetPointer<hitboxes_ *>(VT_HITBOXES);
  }
  const hitboxes_ *multipoints() const {
    return GetPointer<const hitboxes_ *>(VT_MULTIPOINTS);
  }
  hitboxes_ *mutable_multipoints() {
    return GetPointer<hitboxes_ *>(VT_MULTIPOINTS);
  }
  bool autostop() const {
    return GetField<uint8_t>(VT_AUTOSTOP, 0) != 0;
  }
  bool mutate_autostop(bool _autostop = 0) {
    return SetField<uint8_t>(VT_AUTOSTOP, static_cast<uint8_t>(_autostop), 0);
  }
  const autostop_option_ *autostop_option() const {
    return GetPointer<const autostop_option_ *>(VT_AUTOSTOP_OPTION);
  }
  autostop_option_ *mutable_autostop_option() {
    return GetPointer<autostop_option_ *>(VT_AUTOSTOP_OPTION);
  }
  int32_t hitchance_amount() const {
    return GetField<int32_t>(VT_HITCHANCE_AMOUNT, 0);
  }
  bool mutate_hitchance_amount(int32_t _hitchance_amount = 0) {
    return SetField<int32_t>(VT_HITCHANCE_AMOUNT, _hitchance_amount, 0);
  }
  int32_t point_scale() const {
    return GetField<int32_t>(VT_POINT_SCALE, 0);
  }
  bool mutate_point_scale(int32_t _point_scale = 0) {
    return SetField<int32_t>(VT_POINT_SCALE, _point_scale, 0);
  }
  int32_t damage() const {
    return GetField<int32_t>(VT_DAMAGE, 0);
  }
  bool mutate_damage(int32_t _damage = 0) {
    return SetField<int32_t>(VT_DAMAGE, _damage, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_M_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_M_GROUP, 4) &&
           VerifyField<float>(verifier, VT_TEST, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_HITBOXES) &&
           verifier.VerifyTable(hitboxes()) &&
           VerifyOffset(verifier, VT_MULTIPOINTS) &&
           verifier.VerifyTable(multipoints()) &&
           VerifyField<uint8_t>(verifier, VT_AUTOSTOP, 1) &&
           VerifyOffset(verifier, VT_AUTOSTOP_OPTION) &&
           verifier.VerifyTable(autostop_option()) &&
           VerifyField<int32_t>(verifier, VT_HITCHANCE_AMOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_POINT_SCALE, 4) &&
           VerifyField<int32_t>(verifier, VT_DAMAGE, 4) &&
           verifier.EndTable();
  }
  rage_settingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(rage_settingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<rage_settings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const rage_settingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct rage_settingsBuilder {
  typedef rage_settings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_m_index(int32_t m_index) {
    fbb_.AddElement<int32_t>(rage_settings::VT_M_INDEX, m_index, 0);
  }
  void add_m_group(int32_t m_group) {
    fbb_.AddElement<int32_t>(rage_settings::VT_M_GROUP, m_group, 0);
  }
  void add_test(float test) {
    fbb_.AddElement<float>(rage_settings::VT_TEST, test, 0.0f);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(rage_settings::VT_NAME, name);
  }
  void add_hitboxes(::flatbuffers::Offset<hitboxes_> hitboxes) {
    fbb_.AddOffset(rage_settings::VT_HITBOXES, hitboxes);
  }
  void add_multipoints(::flatbuffers::Offset<hitboxes_> multipoints) {
    fbb_.AddOffset(rage_settings::VT_MULTIPOINTS, multipoints);
  }
  void add_autostop(bool autostop) {
    fbb_.AddElement<uint8_t>(rage_settings::VT_AUTOSTOP, static_cast<uint8_t>(autostop), 0);
  }
  void add_autostop_option(::flatbuffers::Offset<autostop_option_> autostop_option) {
    fbb_.AddOffset(rage_settings::VT_AUTOSTOP_OPTION, autostop_option);
  }
  void add_hitchance_amount(int32_t hitchance_amount) {
    fbb_.AddElement<int32_t>(rage_settings::VT_HITCHANCE_AMOUNT, hitchance_amount, 0);
  }
  void add_point_scale(int32_t point_scale) {
    fbb_.AddElement<int32_t>(rage_settings::VT_POINT_SCALE, point_scale, 0);
  }
  void add_damage(int32_t damage) {
    fbb_.AddElement<int32_t>(rage_settings::VT_DAMAGE, damage, 0);
  }
  explicit rage_settingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<rage_settings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<rage_settings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<rage_settings> Createrage_settings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t m_index = 0,
    int32_t m_group = 0,
    float test = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<hitboxes_> hitboxes = 0,
    ::flatbuffers::Offset<hitboxes_> multipoints = 0,
    bool autostop = false,
    ::flatbuffers::Offset<autostop_option_> autostop_option = 0,
    int32_t hitchance_amount = 0,
    int32_t point_scale = 0,
    int32_t damage = 0) {
  rage_settingsBuilder builder_(_fbb);
  builder_.add_damage(damage);
  builder_.add_point_scale(point_scale);
  builder_.add_hitchance_amount(hitchance_amount);
  builder_.add_autostop_option(autostop_option);
  builder_.add_multipoints(multipoints);
  builder_.add_hitboxes(hitboxes);
  builder_.add_name(name);
  builder_.add_test(test);
  builder_.add_m_group(m_group);
  builder_.add_m_index(m_index);
  builder_.add_autostop(autostop);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<rage_settings> Createrage_settingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t m_index = 0,
    int32_t m_group = 0,
    float test = 0.0f,
    const char *name = nullptr,
    ::flatbuffers::Offset<hitboxes_> hitboxes = 0,
    ::flatbuffers::Offset<hitboxes_> multipoints = 0,
    bool autostop = false,
    ::flatbuffers::Offset<autostop_option_> autostop_option = 0,
    int32_t hitchance_amount = 0,
    int32_t point_scale = 0,
    int32_t damage = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Createrage_settings(
      _fbb,
      m_index,
      m_group,
      test,
      name__,
      hitboxes,
      multipoints,
      autostop,
      autostop_option,
      hitchance_amount,
      point_scale,
      damage);
}

::flatbuffers::Offset<rage_settings> Createrage_settings(::flatbuffers::FlatBufferBuilder &_fbb, const rage_settingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const hitboxes_T &lhs, const hitboxes_T &rhs) {
  return
      (lhs.m_head == rhs.m_head) &&
      (lhs.m_chest == rhs.m_chest) &&
      (lhs.m_stomach == rhs.m_stomach) &&
      (lhs.m_arms == rhs.m_arms) &&
      (lhs.m_legs == rhs.m_legs) &&
      (lhs.m_foot == rhs.m_foot);
}

inline bool operator!=(const hitboxes_T &lhs, const hitboxes_T &rhs) {
    return !(lhs == rhs);
}


inline hitboxes_T *hitboxes_::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<hitboxes_T>(new hitboxes_T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void hitboxes_::UnPackTo(hitboxes_T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = m_head(); _o->m_head = _e; }
  { auto _e = m_chest(); _o->m_chest = _e; }
  { auto _e = m_stomach(); _o->m_stomach = _e; }
  { auto _e = m_arms(); _o->m_arms = _e; }
  { auto _e = m_legs(); _o->m_legs = _e; }
  { auto _e = m_foot(); _o->m_foot = _e; }
}

inline ::flatbuffers::Offset<hitboxes_> hitboxes_::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const hitboxes_T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createhitboxes_(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<hitboxes_> Createhitboxes_(::flatbuffers::FlatBufferBuilder &_fbb, const hitboxes_T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const hitboxes_T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _m_head = _o->m_head;
  auto _m_chest = _o->m_chest;
  auto _m_stomach = _o->m_stomach;
  auto _m_arms = _o->m_arms;
  auto _m_legs = _o->m_legs;
  auto _m_foot = _o->m_foot;
  return Createhitboxes_(
      _fbb,
      _m_head,
      _m_chest,
      _m_stomach,
      _m_arms,
      _m_legs,
      _m_foot);
}


inline bool operator==(const autostop_option_T &lhs, const autostop_option_T &rhs) {
  return
      (lhs.m_beetwen_shot == rhs.m_beetwen_shot) &&
      (lhs.m_accuracy == rhs.m_accuracy) &&
      (lhs.m_molotov_ignore == rhs.m_molotov_ignore);
}

inline bool operator!=(const autostop_option_T &lhs, const autostop_option_T &rhs) {
    return !(lhs == rhs);
}


inline autostop_option_T *autostop_option_::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<autostop_option_T>(new autostop_option_T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void autostop_option_::UnPackTo(autostop_option_T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = m_beetwen_shot(); _o->m_beetwen_shot = _e; }
  { auto _e = m_accuracy(); _o->m_accuracy = _e; }
  { auto _e = m_molotov_ignore(); _o->m_molotov_ignore = _e; }
}

inline ::flatbuffers::Offset<autostop_option_> autostop_option_::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const autostop_option_T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createautostop_option_(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<autostop_option_> Createautostop_option_(::flatbuffers::FlatBufferBuilder &_fbb, const autostop_option_T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const autostop_option_T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _m_beetwen_shot = _o->m_beetwen_shot;
  auto _m_accuracy = _o->m_accuracy;
  auto _m_molotov_ignore = _o->m_molotov_ignore;
  return Createautostop_option_(
      _fbb,
      _m_beetwen_shot,
      _m_accuracy,
      _m_molotov_ignore);
}


inline bool operator==(const rage_global_settingsT &lhs, const rage_global_settingsT &rhs) {
  return
      (lhs.m_enabled == rhs.m_enabled) &&
      (lhs.m_auto_fire == rhs.m_auto_fire) &&
      (lhs.m_auto_scope == rhs.m_auto_scope) &&
      (lhs.m_silent == rhs.m_silent) &&
      (lhs.m_penetration == rhs.m_penetration) &&
      (lhs.m_nospread == rhs.m_nospread) &&
      (lhs.m_norecoil == rhs.m_norecoil) &&
      (lhs.m_hideshots == rhs.m_hideshots) &&
      (lhs.backtrack_mode == rhs.backtrack_mode);
}

inline bool operator!=(const rage_global_settingsT &lhs, const rage_global_settingsT &rhs) {
    return !(lhs == rhs);
}


inline rage_global_settingsT *rage_global_settings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<rage_global_settingsT>(new rage_global_settingsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void rage_global_settings::UnPackTo(rage_global_settingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = m_enabled(); _o->m_enabled = _e; }
  { auto _e = m_auto_fire(); _o->m_auto_fire = _e; }
  { auto _e = m_auto_scope(); _o->m_auto_scope = _e; }
  { auto _e = m_silent(); _o->m_silent = _e; }
  { auto _e = m_penetration(); _o->m_penetration = _e; }
  { auto _e = m_nospread(); _o->m_nospread = _e; }
  { auto _e = m_norecoil(); _o->m_norecoil = _e; }
  { auto _e = m_hideshots(); _o->m_hideshots = _e; }
  { auto _e = backtrack_mode(); _o->backtrack_mode = _e; }
}

inline ::flatbuffers::Offset<rage_global_settings> rage_global_settings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const rage_global_settingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createrage_global_settings(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<rage_global_settings> Createrage_global_settings(::flatbuffers::FlatBufferBuilder &_fbb, const rage_global_settingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const rage_global_settingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _m_enabled = _o->m_enabled;
  auto _m_auto_fire = _o->m_auto_fire;
  auto _m_auto_scope = _o->m_auto_scope;
  auto _m_silent = _o->m_silent;
  auto _m_penetration = _o->m_penetration;
  auto _m_nospread = _o->m_nospread;
  auto _m_norecoil = _o->m_norecoil;
  auto _m_hideshots = _o->m_hideshots;
  auto _backtrack_mode = _o->backtrack_mode;
  return Createrage_global_settings(
      _fbb,
      _m_enabled,
      _m_auto_fire,
      _m_auto_scope,
      _m_silent,
      _m_penetration,
      _m_nospread,
      _m_norecoil,
      _m_hideshots,
      _backtrack_mode);
}


inline bool operator==(const rage_settingsT &lhs, const rage_settingsT &rhs) {
  return
      (lhs.m_index == rhs.m_index) &&
      (lhs.m_group == rhs.m_group) &&
      (lhs.test == rhs.test) &&
      (lhs.name == rhs.name) &&
      ((lhs.hitboxes == rhs.hitboxes) || (lhs.hitboxes && rhs.hitboxes && *lhs.hitboxes == *rhs.hitboxes)) &&
      ((lhs.multipoints == rhs.multipoints) || (lhs.multipoints && rhs.multipoints && *lhs.multipoints == *rhs.multipoints)) &&
      (lhs.autostop == rhs.autostop) &&
      ((lhs.autostop_option == rhs.autostop_option) || (lhs.autostop_option && rhs.autostop_option && *lhs.autostop_option == *rhs.autostop_option)) &&
      (lhs.hitchance_amount == rhs.hitchance_amount) &&
      (lhs.point_scale == rhs.point_scale) &&
      (lhs.damage == rhs.damage);
}

inline bool operator!=(const rage_settingsT &lhs, const rage_settingsT &rhs) {
    return !(lhs == rhs);
}


inline rage_settingsT::rage_settingsT(const rage_settingsT &o)
      : m_index(o.m_index),
        m_group(o.m_group),
        test(o.test),
        name(o.name),
        hitboxes((o.hitboxes) ? new hitboxes_T(*o.hitboxes) : nullptr),
        multipoints((o.multipoints) ? new hitboxes_T(*o.multipoints) : nullptr),
        autostop(o.autostop),
        autostop_option((o.autostop_option) ? new autostop_option_T(*o.autostop_option) : nullptr),
        hitchance_amount(o.hitchance_amount),
        point_scale(o.point_scale),
        damage(o.damage) {
}

inline rage_settingsT &rage_settingsT::operator=(rage_settingsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(m_index, o.m_index);
  std::swap(m_group, o.m_group);
  std::swap(test, o.test);
  std::swap(name, o.name);
  std::swap(hitboxes, o.hitboxes);
  std::swap(multipoints, o.multipoints);
  std::swap(autostop, o.autostop);
  std::swap(autostop_option, o.autostop_option);
  std::swap(hitchance_amount, o.hitchance_amount);
  std::swap(point_scale, o.point_scale);
  std::swap(damage, o.damage);
  return *this;
}

inline rage_settingsT *rage_settings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<rage_settingsT>(new rage_settingsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void rage_settings::UnPackTo(rage_settingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = m_index(); _o->m_index = _e; }
  { auto _e = m_group(); _o->m_group = _e; }
  { auto _e = test(); _o->test = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = hitboxes(); if (_e) { if(_o->hitboxes) { _e->UnPackTo(_o->hitboxes.get(), _resolver); } else { _o->hitboxes = std::unique_ptr<hitboxes_T>(_e->UnPack(_resolver)); } } else if (_o->hitboxes) { _o->hitboxes.reset(); } }
  { auto _e = multipoints(); if (_e) { if(_o->multipoints) { _e->UnPackTo(_o->multipoints.get(), _resolver); } else { _o->multipoints = std::unique_ptr<hitboxes_T>(_e->UnPack(_resolver)); } } else if (_o->multipoints) { _o->multipoints.reset(); } }
  { auto _e = autostop(); _o->autostop = _e; }
  { auto _e = autostop_option(); if (_e) { if(_o->autostop_option) { _e->UnPackTo(_o->autostop_option.get(), _resolver); } else { _o->autostop_option = std::unique_ptr<autostop_option_T>(_e->UnPack(_resolver)); } } else if (_o->autostop_option) { _o->autostop_option.reset(); } }
  { auto _e = hitchance_amount(); _o->hitchance_amount = _e; }
  { auto _e = point_scale(); _o->point_scale = _e; }
  { auto _e = damage(); _o->damage = _e; }
}

inline ::flatbuffers::Offset<rage_settings> rage_settings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const rage_settingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createrage_settings(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<rage_settings> Createrage_settings(::flatbuffers::FlatBufferBuilder &_fbb, const rage_settingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const rage_settingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _m_index = _o->m_index;
  auto _m_group = _o->m_group;
  auto _test = _o->test;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _hitboxes = _o->hitboxes ? Createhitboxes_(_fbb, _o->hitboxes.get(), _rehasher) : 0;
  auto _multipoints = _o->multipoints ? Createhitboxes_(_fbb, _o->multipoints.get(), _rehasher) : 0;
  auto _autostop = _o->autostop;
  auto _autostop_option = _o->autostop_option ? Createautostop_option_(_fbb, _o->autostop_option.get(), _rehasher) : 0;
  auto _hitchance_amount = _o->hitchance_amount;
  auto _point_scale = _o->point_scale;
  auto _damage = _o->damage;
  return Createrage_settings(
      _fbb,
      _m_index,
      _m_group,
      _test,
      _name,
      _hitboxes,
      _multipoints,
      _autostop,
      _autostop_option,
      _hitchance_amount,
      _point_scale,
      _damage);
}

inline const ::flatbuffers::TypeTable *hitboxes_TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "m_head",
    "m_chest",
    "m_stomach",
    "m_arms",
    "m_legs",
    "m_foot"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *autostop_option_TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "m_beetwen_shot",
    "m_accuracy",
    "m_molotov_ignore"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *rage_global_settingsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "m_enabled",
    "m_auto_fire",
    "m_auto_scope",
    "m_silent",
    "m_penetration",
    "m_nospread",
    "m_norecoil",
    "m_hideshots",
    "backtrack_mode"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 9, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *rage_settingsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    hitboxes_TypeTable,
    autostop_option_TypeTable
  };
  static const char * const names[] = {
    "m_index",
    "m_group",
    "test",
    "name",
    "hitboxes",
    "multipoints",
    "autostop",
    "autostop_option",
    "hitchance_amount",
    "point_scale",
    "damage"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_RAGESETTINGSTABLE_H_
