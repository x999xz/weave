// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESPONSETABLE_H_
#define FLATBUFFERS_GENERATED_RESPONSETABLE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct Response;
struct ResponseBuilder;
struct ResponseT;

struct ConfigResponse;
struct ConfigResponseBuilder;
struct ConfigResponseT;

bool operator==(const ResponseT &lhs, const ResponseT &rhs);
bool operator!=(const ResponseT &lhs, const ResponseT &rhs);
bool operator==(const ConfigResponseT &lhs, const ConfigResponseT &rhs);
bool operator!=(const ConfigResponseT &lhs, const ConfigResponseT &rhs);

inline const ::flatbuffers::TypeTable *ResponseTypeTable();

inline const ::flatbuffers::TypeTable *ConfigResponseTypeTable();

struct ResponseT : public ::flatbuffers::NativeTable {
  typedef Response TableType;
  std::string error{};
  std::string data{};
};

struct Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseT NativeTableType;
  typedef ResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4,
    VT_DATA = 6
  };
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  ::flatbuffers::String *mutable_error() {
    return GetPointer<::flatbuffers::String *>(VT_ERROR);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  ::flatbuffers::String *mutable_data() {
    return GetPointer<::flatbuffers::String *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
  ResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Response> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResponseBuilder {
  typedef Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(Response::VT_ERROR, error);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(Response::VT_DATA, data);
  }
  explicit ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response> CreateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_error(error);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response> CreateResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr,
    const char *data = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return CreateResponse(
      _fbb,
      error__,
      data__);
}

::flatbuffers::Offset<Response> CreateResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConfigResponseT : public ::flatbuffers::NativeTable {
  typedef ConfigResponse TableType;
  std::string name{};
  std::string value{};
  std::string share{};
  int64_t updated = 0;
  int64_t created = 0;
  std::string user{};
  std::string owner{};
};

struct ConfigResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigResponseT NativeTableType;
  typedef ConfigResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConfigResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6,
    VT_SHARE = 8,
    VT_UPDATED = 10,
    VT_CREATED = 12,
    VT_USER = 14,
    VT_OWNER = 16
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  ::flatbuffers::String *mutable_value() {
    return GetPointer<::flatbuffers::String *>(VT_VALUE);
  }
  const ::flatbuffers::String *share() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHARE);
  }
  ::flatbuffers::String *mutable_share() {
    return GetPointer<::flatbuffers::String *>(VT_SHARE);
  }
  int64_t updated() const {
    return GetField<int64_t>(VT_UPDATED, 0);
  }
  bool mutate_updated(int64_t _updated = 0) {
    return SetField<int64_t>(VT_UPDATED, _updated, 0);
  }
  int64_t created() const {
    return GetField<int64_t>(VT_CREATED, 0);
  }
  bool mutate_created(int64_t _created = 0) {
    return SetField<int64_t>(VT_CREATED, _created, 0);
  }
  const ::flatbuffers::String *user() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER);
  }
  ::flatbuffers::String *mutable_user() {
    return GetPointer<::flatbuffers::String *>(VT_USER);
  }
  const ::flatbuffers::String *owner() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OWNER);
  }
  ::flatbuffers::String *mutable_owner() {
    return GetPointer<::flatbuffers::String *>(VT_OWNER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           VerifyOffset(verifier, VT_SHARE) &&
           verifier.VerifyString(share()) &&
           VerifyField<int64_t>(verifier, VT_UPDATED, 8) &&
           VerifyField<int64_t>(verifier, VT_CREATED, 8) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyString(user()) &&
           VerifyOffset(verifier, VT_OWNER) &&
           verifier.VerifyString(owner()) &&
           verifier.EndTable();
  }
  ConfigResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConfigResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ConfigResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConfigResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConfigResponseBuilder {
  typedef ConfigResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ConfigResponse::VT_NAME, name);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(ConfigResponse::VT_VALUE, value);
  }
  void add_share(::flatbuffers::Offset<::flatbuffers::String> share) {
    fbb_.AddOffset(ConfigResponse::VT_SHARE, share);
  }
  void add_updated(int64_t updated) {
    fbb_.AddElement<int64_t>(ConfigResponse::VT_UPDATED, updated, 0);
  }
  void add_created(int64_t created) {
    fbb_.AddElement<int64_t>(ConfigResponse::VT_CREATED, created, 0);
  }
  void add_user(::flatbuffers::Offset<::flatbuffers::String> user) {
    fbb_.AddOffset(ConfigResponse::VT_USER, user);
  }
  void add_owner(::flatbuffers::Offset<::flatbuffers::String> owner) {
    fbb_.AddOffset(ConfigResponse::VT_OWNER, owner);
  }
  explicit ConfigResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigResponse> CreateConfigResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> share = 0,
    int64_t updated = 0,
    int64_t created = 0,
    ::flatbuffers::Offset<::flatbuffers::String> user = 0,
    ::flatbuffers::Offset<::flatbuffers::String> owner = 0) {
  ConfigResponseBuilder builder_(_fbb);
  builder_.add_created(created);
  builder_.add_updated(updated);
  builder_.add_owner(owner);
  builder_.add_user(user);
  builder_.add_share(share);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConfigResponse> CreateConfigResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *value = nullptr,
    const char *share = nullptr,
    int64_t updated = 0,
    int64_t created = 0,
    const char *user = nullptr,
    const char *owner = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  auto share__ = share ? _fbb.CreateString(share) : 0;
  auto user__ = user ? _fbb.CreateString(user) : 0;
  auto owner__ = owner ? _fbb.CreateString(owner) : 0;
  return CreateConfigResponse(
      _fbb,
      name__,
      value__,
      share__,
      updated,
      created,
      user__,
      owner__);
}

::flatbuffers::Offset<ConfigResponse> CreateConfigResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ConfigResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const ResponseT &lhs, const ResponseT &rhs) {
  return
      (lhs.error == rhs.error) &&
      (lhs.data == rhs.data);
}

inline bool operator!=(const ResponseT &lhs, const ResponseT &rhs) {
    return !(lhs == rhs);
}


inline ResponseT *Response::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ResponseT>(new ResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response::UnPackTo(ResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error(); if (_e) _o->error = _e->str(); }
  { auto _e = data(); if (_e) _o->data = _e->str(); }
}

inline ::flatbuffers::Offset<Response> Response::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Response> CreateResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  auto _data = _o->data.empty() ? 0 : _fbb.CreateString(_o->data);
  return CreateResponse(
      _fbb,
      _error,
      _data);
}


inline bool operator==(const ConfigResponseT &lhs, const ConfigResponseT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.value == rhs.value) &&
      (lhs.share == rhs.share) &&
      (lhs.updated == rhs.updated) &&
      (lhs.created == rhs.created) &&
      (lhs.user == rhs.user) &&
      (lhs.owner == rhs.owner);
}

inline bool operator!=(const ConfigResponseT &lhs, const ConfigResponseT &rhs) {
    return !(lhs == rhs);
}


inline ConfigResponseT *ConfigResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConfigResponseT>(new ConfigResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConfigResponse::UnPackTo(ConfigResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value(); if (_e) _o->value = _e->str(); }
  { auto _e = share(); if (_e) _o->share = _e->str(); }
  { auto _e = updated(); _o->updated = _e; }
  { auto _e = created(); _o->created = _e; }
  { auto _e = user(); if (_e) _o->user = _e->str(); }
  { auto _e = owner(); if (_e) _o->owner = _e->str(); }
}

inline ::flatbuffers::Offset<ConfigResponse> ConfigResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConfigResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConfigResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ConfigResponse> CreateConfigResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ConfigResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConfigResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
  auto _share = _o->share.empty() ? 0 : _fbb.CreateString(_o->share);
  auto _updated = _o->updated;
  auto _created = _o->created;
  auto _user = _o->user.empty() ? 0 : _fbb.CreateString(_o->user);
  auto _owner = _o->owner.empty() ? 0 : _fbb.CreateString(_o->owner);
  return CreateConfigResponse(
      _fbb,
      _name,
      _value,
      _share,
      _updated,
      _created,
      _user,
      _owner);
}

inline const ::flatbuffers::TypeTable *ResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "error",
    "data"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ConfigResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "name",
    "value",
    "share",
    "updated",
    "created",
    "user",
    "owner"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_RESPONSETABLE_H_
