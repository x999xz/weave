// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ANTIAIMTABLE_H_
#define FLATBUFFERS_GENERATED_ANTIAIMTABLE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct antiaim;
struct antiaimBuilder;
struct antiaimT;

bool operator==(const antiaimT &lhs, const antiaimT &rhs);
bool operator!=(const antiaimT &lhs, const antiaimT &rhs);

inline const ::flatbuffers::TypeTable *antiaimTypeTable();

struct antiaimT : public ::flatbuffers::NativeTable {
  typedef antiaim TableType;
  bool enabled = false;
  bool at_target = false;
  int32_t pitch = 0;
  int32_t yaw = 0;
  int32_t yaw_offset = 0;
  int32_t jitter = 0;
};

struct antiaim FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef antiaimT NativeTableType;
  typedef antiaimBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return antiaimTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_AT_TARGET = 6,
    VT_PITCH = 8,
    VT_YAW = 10,
    VT_YAW_OFFSET = 12,
    VT_JITTER = 14
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  bool mutate_enabled(bool _enabled = 0) {
    return SetField<uint8_t>(VT_ENABLED, static_cast<uint8_t>(_enabled), 0);
  }
  bool at_target() const {
    return GetField<uint8_t>(VT_AT_TARGET, 0) != 0;
  }
  bool mutate_at_target(bool _at_target = 0) {
    return SetField<uint8_t>(VT_AT_TARGET, static_cast<uint8_t>(_at_target), 0);
  }
  int32_t pitch() const {
    return GetField<int32_t>(VT_PITCH, 0);
  }
  bool mutate_pitch(int32_t _pitch = 0) {
    return SetField<int32_t>(VT_PITCH, _pitch, 0);
  }
  int32_t yaw() const {
    return GetField<int32_t>(VT_YAW, 0);
  }
  bool mutate_yaw(int32_t _yaw = 0) {
    return SetField<int32_t>(VT_YAW, _yaw, 0);
  }
  int32_t yaw_offset() const {
    return GetField<int32_t>(VT_YAW_OFFSET, 0);
  }
  bool mutate_yaw_offset(int32_t _yaw_offset = 0) {
    return SetField<int32_t>(VT_YAW_OFFSET, _yaw_offset, 0);
  }
  int32_t jitter() const {
    return GetField<int32_t>(VT_JITTER, 0);
  }
  bool mutate_jitter(int32_t _jitter = 0) {
    return SetField<int32_t>(VT_JITTER, _jitter, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_AT_TARGET, 1) &&
           VerifyField<int32_t>(verifier, VT_PITCH, 4) &&
           VerifyField<int32_t>(verifier, VT_YAW, 4) &&
           VerifyField<int32_t>(verifier, VT_YAW_OFFSET, 4) &&
           VerifyField<int32_t>(verifier, VT_JITTER, 4) &&
           verifier.EndTable();
  }
  antiaimT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(antiaimT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<antiaim> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const antiaimT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct antiaimBuilder {
  typedef antiaim Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(antiaim::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_at_target(bool at_target) {
    fbb_.AddElement<uint8_t>(antiaim::VT_AT_TARGET, static_cast<uint8_t>(at_target), 0);
  }
  void add_pitch(int32_t pitch) {
    fbb_.AddElement<int32_t>(antiaim::VT_PITCH, pitch, 0);
  }
  void add_yaw(int32_t yaw) {
    fbb_.AddElement<int32_t>(antiaim::VT_YAW, yaw, 0);
  }
  void add_yaw_offset(int32_t yaw_offset) {
    fbb_.AddElement<int32_t>(antiaim::VT_YAW_OFFSET, yaw_offset, 0);
  }
  void add_jitter(int32_t jitter) {
    fbb_.AddElement<int32_t>(antiaim::VT_JITTER, jitter, 0);
  }
  explicit antiaimBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<antiaim> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<antiaim>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<antiaim> Createantiaim(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    bool at_target = false,
    int32_t pitch = 0,
    int32_t yaw = 0,
    int32_t yaw_offset = 0,
    int32_t jitter = 0) {
  antiaimBuilder builder_(_fbb);
  builder_.add_jitter(jitter);
  builder_.add_yaw_offset(yaw_offset);
  builder_.add_yaw(yaw);
  builder_.add_pitch(pitch);
  builder_.add_at_target(at_target);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

::flatbuffers::Offset<antiaim> Createantiaim(::flatbuffers::FlatBufferBuilder &_fbb, const antiaimT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const antiaimT &lhs, const antiaimT &rhs) {
  return
      (lhs.enabled == rhs.enabled) &&
      (lhs.at_target == rhs.at_target) &&
      (lhs.pitch == rhs.pitch) &&
      (lhs.yaw == rhs.yaw) &&
      (lhs.yaw_offset == rhs.yaw_offset) &&
      (lhs.jitter == rhs.jitter);
}

inline bool operator!=(const antiaimT &lhs, const antiaimT &rhs) {
    return !(lhs == rhs);
}


inline antiaimT *antiaim::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<antiaimT>(new antiaimT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void antiaim::UnPackTo(antiaimT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enabled(); _o->enabled = _e; }
  { auto _e = at_target(); _o->at_target = _e; }
  { auto _e = pitch(); _o->pitch = _e; }
  { auto _e = yaw(); _o->yaw = _e; }
  { auto _e = yaw_offset(); _o->yaw_offset = _e; }
  { auto _e = jitter(); _o->jitter = _e; }
}

inline ::flatbuffers::Offset<antiaim> antiaim::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const antiaimT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createantiaim(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<antiaim> Createantiaim(::flatbuffers::FlatBufferBuilder &_fbb, const antiaimT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const antiaimT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enabled = _o->enabled;
  auto _at_target = _o->at_target;
  auto _pitch = _o->pitch;
  auto _yaw = _o->yaw;
  auto _yaw_offset = _o->yaw_offset;
  auto _jitter = _o->jitter;
  return Createantiaim(
      _fbb,
      _enabled,
      _at_target,
      _pitch,
      _yaw,
      _yaw_offset,
      _jitter);
}

inline const ::flatbuffers::TypeTable *antiaimTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "enabled",
    "at_target",
    "pitch",
    "yaw",
    "yaw_offset",
    "jitter"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_ANTIAIMTABLE_H_
