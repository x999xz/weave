// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CONFIGTABLE_H_
#define FLATBUFFERS_GENERATED_CONFIGTABLE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "antiaim_table_generated.h"
#include "legit_settings_table_generated.h"
#include "misc_table_generated.h"
#include "rage_settings_table_generated.h"
#include "visuals_table_generated.h"

struct Hotkey_;
struct Hotkey_Builder;
struct Hotkey_T;

struct Inventory;
struct InventoryBuilder;
struct InventoryT;

struct Item;
struct ItemBuilder;
struct ItemT;

struct ConfigSettings;
struct ConfigSettingsBuilder;
struct ConfigSettingsT;

bool operator==(const Hotkey_T &lhs, const Hotkey_T &rhs);
bool operator!=(const Hotkey_T &lhs, const Hotkey_T &rhs);
bool operator==(const InventoryT &lhs, const InventoryT &rhs);
bool operator!=(const InventoryT &lhs, const InventoryT &rhs);
bool operator==(const ItemT &lhs, const ItemT &rhs);
bool operator!=(const ItemT &lhs, const ItemT &rhs);
bool operator==(const ConfigSettingsT &lhs, const ConfigSettingsT &rhs);
bool operator!=(const ConfigSettingsT &lhs, const ConfigSettingsT &rhs);

inline const ::flatbuffers::TypeTable *Hotkey_TypeTable();

inline const ::flatbuffers::TypeTable *InventoryTypeTable();

inline const ::flatbuffers::TypeTable *ItemTypeTable();

inline const ::flatbuffers::TypeTable *ConfigSettingsTypeTable();

struct Hotkey_T : public ::flatbuffers::NativeTable {
  typedef Hotkey_ TableType;
  uint64_t hash = 0;
  int32_t key = 0;
  int32_t mode = 0;
  bool visible = false;
  int32_t type = 0;
  std::vector<std::string> name_visual{};
  std::vector<std::string> name{};
  std::vector<double> value{};
};

struct Hotkey_ FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Hotkey_T NativeTableType;
  typedef Hotkey_Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Hotkey_TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH = 4,
    VT_KEY = 6,
    VT_MODE = 8,
    VT_VISIBLE = 10,
    VT_TYPE = 12,
    VT_NAME_VISUAL = 14,
    VT_NAME = 16,
    VT_VALUE = 18
  };
  uint64_t hash() const {
    return GetField<uint64_t>(VT_HASH, 0);
  }
  bool mutate_hash(uint64_t _hash = 0) {
    return SetField<uint64_t>(VT_HASH, _hash, 0);
  }
  int32_t key() const {
    return GetField<int32_t>(VT_KEY, 0);
  }
  bool mutate_key(int32_t _key = 0) {
    return SetField<int32_t>(VT_KEY, _key, 0);
  }
  int32_t mode() const {
    return GetField<int32_t>(VT_MODE, 0);
  }
  bool mutate_mode(int32_t _mode = 0) {
    return SetField<int32_t>(VT_MODE, _mode, 0);
  }
  bool visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool mutate_visible(bool _visible = 0) {
    return SetField<uint8_t>(VT_VISIBLE, static_cast<uint8_t>(_visible), 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type = 0) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *name_visual() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_NAME_VISUAL);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_name_visual() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_NAME_VISUAL);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *name() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_NAME);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_name() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_NAME);
  }
  const ::flatbuffers::Vector<double> *value() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<double> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<double> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_HASH, 8) &&
           VerifyField<int32_t>(verifier, VT_KEY, 4) &&
           VerifyField<int32_t>(verifier, VT_MODE, 4) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE, 1) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyOffset(verifier, VT_NAME_VISUAL) &&
           verifier.VerifyVector(name_visual()) &&
           verifier.VerifyVectorOfStrings(name_visual()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyVector(name()) &&
           verifier.VerifyVectorOfStrings(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  Hotkey_T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Hotkey_T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Hotkey_> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Hotkey_T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Hotkey_Builder {
  typedef Hotkey_ Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_hash(uint64_t hash) {
    fbb_.AddElement<uint64_t>(Hotkey_::VT_HASH, hash, 0);
  }
  void add_key(int32_t key) {
    fbb_.AddElement<int32_t>(Hotkey_::VT_KEY, key, 0);
  }
  void add_mode(int32_t mode) {
    fbb_.AddElement<int32_t>(Hotkey_::VT_MODE, mode, 0);
  }
  void add_visible(bool visible) {
    fbb_.AddElement<uint8_t>(Hotkey_::VT_VISIBLE, static_cast<uint8_t>(visible), 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Hotkey_::VT_TYPE, type, 0);
  }
  void add_name_visual(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> name_visual) {
    fbb_.AddOffset(Hotkey_::VT_NAME_VISUAL, name_visual);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> name) {
    fbb_.AddOffset(Hotkey_::VT_NAME, name);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<double>> value) {
    fbb_.AddOffset(Hotkey_::VT_VALUE, value);
  }
  explicit Hotkey_Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Hotkey_> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Hotkey_>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Hotkey_> CreateHotkey_(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t hash = 0,
    int32_t key = 0,
    int32_t mode = 0,
    bool visible = false,
    int32_t type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> name_visual = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> value = 0) {
  Hotkey_Builder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_name_visual(name_visual);
  builder_.add_type(type);
  builder_.add_mode(mode);
  builder_.add_key(key);
  builder_.add_visible(visible);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Hotkey_> CreateHotkey_Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t hash = 0,
    int32_t key = 0,
    int32_t mode = 0,
    bool visible = false,
    int32_t type = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *name_visual = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *name = nullptr,
    const std::vector<double> *value = nullptr) {
  auto name_visual__ = name_visual ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*name_visual) : 0;
  auto name__ = name ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*name) : 0;
  auto value__ = value ? _fbb.CreateVector<double>(*value) : 0;
  return CreateHotkey_(
      _fbb,
      hash,
      key,
      mode,
      visible,
      type,
      name_visual__,
      name__,
      value__);
}

::flatbuffers::Offset<Hotkey_> CreateHotkey_(::flatbuffers::FlatBufferBuilder &_fbb, const Hotkey_T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InventoryT : public ::flatbuffers::NativeTable {
  typedef Inventory TableType;
  uint64_t item_id = 0;
  int32_t team = 0;
  int32_t slot = 0;
};

struct Inventory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InventoryT NativeTableType;
  typedef InventoryBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InventoryTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM_ID = 4,
    VT_TEAM = 6,
    VT_SLOT = 8
  };
  uint64_t item_id() const {
    return GetField<uint64_t>(VT_ITEM_ID, 0);
  }
  bool mutate_item_id(uint64_t _item_id = 0) {
    return SetField<uint64_t>(VT_ITEM_ID, _item_id, 0);
  }
  int32_t team() const {
    return GetField<int32_t>(VT_TEAM, 0);
  }
  bool mutate_team(int32_t _team = 0) {
    return SetField<int32_t>(VT_TEAM, _team, 0);
  }
  int32_t slot() const {
    return GetField<int32_t>(VT_SLOT, 0);
  }
  bool mutate_slot(int32_t _slot = 0) {
    return SetField<int32_t>(VT_SLOT, _slot, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ITEM_ID, 8) &&
           VerifyField<int32_t>(verifier, VT_TEAM, 4) &&
           VerifyField<int32_t>(verifier, VT_SLOT, 4) &&
           verifier.EndTable();
  }
  InventoryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InventoryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Inventory> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InventoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InventoryBuilder {
  typedef Inventory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item_id(uint64_t item_id) {
    fbb_.AddElement<uint64_t>(Inventory::VT_ITEM_ID, item_id, 0);
  }
  void add_team(int32_t team) {
    fbb_.AddElement<int32_t>(Inventory::VT_TEAM, team, 0);
  }
  void add_slot(int32_t slot) {
    fbb_.AddElement<int32_t>(Inventory::VT_SLOT, slot, 0);
  }
  explicit InventoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Inventory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Inventory>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Inventory> CreateInventory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t item_id = 0,
    int32_t team = 0,
    int32_t slot = 0) {
  InventoryBuilder builder_(_fbb);
  builder_.add_item_id(item_id);
  builder_.add_slot(slot);
  builder_.add_team(team);
  return builder_.Finish();
}

::flatbuffers::Offset<Inventory> CreateInventory(::flatbuffers::FlatBufferBuilder &_fbb, const InventoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ItemT : public ::flatbuffers::NativeTable {
  typedef Item TableType;
  int32_t item_def = 0;
  std::string paint_name{};
  std::string name{};
  uint64_t skin_key = 0;
  int32_t paint_id = 0;
  int32_t rariry = 0;
  int32_t texture_id = 0;
  int32_t type = 0;
  std::string path_image{};
  bool is_initilization = false;
  int32_t paint_seed = 0;
  int32_t paint_wear = 0;
  int32_t stattrack = 0;
  int32_t stickers_0 = 0;
  int32_t stickers_1 = 0;
  int32_t stickers_2 = 0;
  int32_t stickers_3 = 0;
  int32_t stickers_4 = 0;
  std::string custom_name{};
  uint64_t id = 0;
};

struct Item FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ItemT NativeTableType;
  typedef ItemBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ItemTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM_DEF = 4,
    VT_PAINT_NAME = 6,
    VT_NAME = 8,
    VT_SKIN_KEY = 10,
    VT_PAINT_ID = 12,
    VT_RARIRY = 14,
    VT_TEXTURE_ID = 16,
    VT_TYPE = 18,
    VT_PATH_IMAGE = 20,
    VT_IS_INITILIZATION = 22,
    VT_PAINT_SEED = 24,
    VT_PAINT_WEAR = 26,
    VT_STATTRACK = 28,
    VT_STICKERS_0 = 30,
    VT_STICKERS_1 = 32,
    VT_STICKERS_2 = 34,
    VT_STICKERS_3 = 36,
    VT_STICKERS_4 = 38,
    VT_CUSTOM_NAME = 40,
    VT_ID = 42
  };
  int32_t item_def() const {
    return GetField<int32_t>(VT_ITEM_DEF, 0);
  }
  bool mutate_item_def(int32_t _item_def = 0) {
    return SetField<int32_t>(VT_ITEM_DEF, _item_def, 0);
  }
  const ::flatbuffers::String *paint_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAINT_NAME);
  }
  ::flatbuffers::String *mutable_paint_name() {
    return GetPointer<::flatbuffers::String *>(VT_PAINT_NAME);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  uint64_t skin_key() const {
    return GetField<uint64_t>(VT_SKIN_KEY, 0);
  }
  bool mutate_skin_key(uint64_t _skin_key = 0) {
    return SetField<uint64_t>(VT_SKIN_KEY, _skin_key, 0);
  }
  int32_t paint_id() const {
    return GetField<int32_t>(VT_PAINT_ID, 0);
  }
  bool mutate_paint_id(int32_t _paint_id = 0) {
    return SetField<int32_t>(VT_PAINT_ID, _paint_id, 0);
  }
  int32_t rariry() const {
    return GetField<int32_t>(VT_RARIRY, 0);
  }
  bool mutate_rariry(int32_t _rariry = 0) {
    return SetField<int32_t>(VT_RARIRY, _rariry, 0);
  }
  int32_t texture_id() const {
    return GetField<int32_t>(VT_TEXTURE_ID, 0);
  }
  bool mutate_texture_id(int32_t _texture_id = 0) {
    return SetField<int32_t>(VT_TEXTURE_ID, _texture_id, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type = 0) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  const ::flatbuffers::String *path_image() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH_IMAGE);
  }
  ::flatbuffers::String *mutable_path_image() {
    return GetPointer<::flatbuffers::String *>(VT_PATH_IMAGE);
  }
  bool is_initilization() const {
    return GetField<uint8_t>(VT_IS_INITILIZATION, 0) != 0;
  }
  bool mutate_is_initilization(bool _is_initilization = 0) {
    return SetField<uint8_t>(VT_IS_INITILIZATION, static_cast<uint8_t>(_is_initilization), 0);
  }
  int32_t paint_seed() const {
    return GetField<int32_t>(VT_PAINT_SEED, 0);
  }
  bool mutate_paint_seed(int32_t _paint_seed = 0) {
    return SetField<int32_t>(VT_PAINT_SEED, _paint_seed, 0);
  }
  int32_t paint_wear() const {
    return GetField<int32_t>(VT_PAINT_WEAR, 0);
  }
  bool mutate_paint_wear(int32_t _paint_wear = 0) {
    return SetField<int32_t>(VT_PAINT_WEAR, _paint_wear, 0);
  }
  int32_t stattrack() const {
    return GetField<int32_t>(VT_STATTRACK, 0);
  }
  bool mutate_stattrack(int32_t _stattrack = 0) {
    return SetField<int32_t>(VT_STATTRACK, _stattrack, 0);
  }
  int32_t stickers_0() const {
    return GetField<int32_t>(VT_STICKERS_0, 0);
  }
  bool mutate_stickers_0(int32_t _stickers_0 = 0) {
    return SetField<int32_t>(VT_STICKERS_0, _stickers_0, 0);
  }
  int32_t stickers_1() const {
    return GetField<int32_t>(VT_STICKERS_1, 0);
  }
  bool mutate_stickers_1(int32_t _stickers_1 = 0) {
    return SetField<int32_t>(VT_STICKERS_1, _stickers_1, 0);
  }
  int32_t stickers_2() const {
    return GetField<int32_t>(VT_STICKERS_2, 0);
  }
  bool mutate_stickers_2(int32_t _stickers_2 = 0) {
    return SetField<int32_t>(VT_STICKERS_2, _stickers_2, 0);
  }
  int32_t stickers_3() const {
    return GetField<int32_t>(VT_STICKERS_3, 0);
  }
  bool mutate_stickers_3(int32_t _stickers_3 = 0) {
    return SetField<int32_t>(VT_STICKERS_3, _stickers_3, 0);
  }
  int32_t stickers_4() const {
    return GetField<int32_t>(VT_STICKERS_4, 0);
  }
  bool mutate_stickers_4(int32_t _stickers_4 = 0) {
    return SetField<int32_t>(VT_STICKERS_4, _stickers_4, 0);
  }
  const ::flatbuffers::String *custom_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CUSTOM_NAME);
  }
  ::flatbuffers::String *mutable_custom_name() {
    return GetPointer<::flatbuffers::String *>(VT_CUSTOM_NAME);
  }
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEM_DEF, 4) &&
           VerifyOffset(verifier, VT_PAINT_NAME) &&
           verifier.VerifyString(paint_name()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_SKIN_KEY, 8) &&
           VerifyField<int32_t>(verifier, VT_PAINT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_RARIRY, 4) &&
           VerifyField<int32_t>(verifier, VT_TEXTURE_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyOffset(verifier, VT_PATH_IMAGE) &&
           verifier.VerifyString(path_image()) &&
           VerifyField<uint8_t>(verifier, VT_IS_INITILIZATION, 1) &&
           VerifyField<int32_t>(verifier, VT_PAINT_SEED, 4) &&
           VerifyField<int32_t>(verifier, VT_PAINT_WEAR, 4) &&
           VerifyField<int32_t>(verifier, VT_STATTRACK, 4) &&
           VerifyField<int32_t>(verifier, VT_STICKERS_0, 4) &&
           VerifyField<int32_t>(verifier, VT_STICKERS_1, 4) &&
           VerifyField<int32_t>(verifier, VT_STICKERS_2, 4) &&
           VerifyField<int32_t>(verifier, VT_STICKERS_3, 4) &&
           VerifyField<int32_t>(verifier, VT_STICKERS_4, 4) &&
           VerifyOffset(verifier, VT_CUSTOM_NAME) &&
           verifier.VerifyString(custom_name()) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           verifier.EndTable();
  }
  ItemT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Item> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ItemBuilder {
  typedef Item Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item_def(int32_t item_def) {
    fbb_.AddElement<int32_t>(Item::VT_ITEM_DEF, item_def, 0);
  }
  void add_paint_name(::flatbuffers::Offset<::flatbuffers::String> paint_name) {
    fbb_.AddOffset(Item::VT_PAINT_NAME, paint_name);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Item::VT_NAME, name);
  }
  void add_skin_key(uint64_t skin_key) {
    fbb_.AddElement<uint64_t>(Item::VT_SKIN_KEY, skin_key, 0);
  }
  void add_paint_id(int32_t paint_id) {
    fbb_.AddElement<int32_t>(Item::VT_PAINT_ID, paint_id, 0);
  }
  void add_rariry(int32_t rariry) {
    fbb_.AddElement<int32_t>(Item::VT_RARIRY, rariry, 0);
  }
  void add_texture_id(int32_t texture_id) {
    fbb_.AddElement<int32_t>(Item::VT_TEXTURE_ID, texture_id, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Item::VT_TYPE, type, 0);
  }
  void add_path_image(::flatbuffers::Offset<::flatbuffers::String> path_image) {
    fbb_.AddOffset(Item::VT_PATH_IMAGE, path_image);
  }
  void add_is_initilization(bool is_initilization) {
    fbb_.AddElement<uint8_t>(Item::VT_IS_INITILIZATION, static_cast<uint8_t>(is_initilization), 0);
  }
  void add_paint_seed(int32_t paint_seed) {
    fbb_.AddElement<int32_t>(Item::VT_PAINT_SEED, paint_seed, 0);
  }
  void add_paint_wear(int32_t paint_wear) {
    fbb_.AddElement<int32_t>(Item::VT_PAINT_WEAR, paint_wear, 0);
  }
  void add_stattrack(int32_t stattrack) {
    fbb_.AddElement<int32_t>(Item::VT_STATTRACK, stattrack, 0);
  }
  void add_stickers_0(int32_t stickers_0) {
    fbb_.AddElement<int32_t>(Item::VT_STICKERS_0, stickers_0, 0);
  }
  void add_stickers_1(int32_t stickers_1) {
    fbb_.AddElement<int32_t>(Item::VT_STICKERS_1, stickers_1, 0);
  }
  void add_stickers_2(int32_t stickers_2) {
    fbb_.AddElement<int32_t>(Item::VT_STICKERS_2, stickers_2, 0);
  }
  void add_stickers_3(int32_t stickers_3) {
    fbb_.AddElement<int32_t>(Item::VT_STICKERS_3, stickers_3, 0);
  }
  void add_stickers_4(int32_t stickers_4) {
    fbb_.AddElement<int32_t>(Item::VT_STICKERS_4, stickers_4, 0);
  }
  void add_custom_name(::flatbuffers::Offset<::flatbuffers::String> custom_name) {
    fbb_.AddOffset(Item::VT_CUSTOM_NAME, custom_name);
  }
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Item::VT_ID, id, 0);
  }
  explicit ItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Item> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Item>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Item> CreateItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item_def = 0,
    ::flatbuffers::Offset<::flatbuffers::String> paint_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint64_t skin_key = 0,
    int32_t paint_id = 0,
    int32_t rariry = 0,
    int32_t texture_id = 0,
    int32_t type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> path_image = 0,
    bool is_initilization = false,
    int32_t paint_seed = 0,
    int32_t paint_wear = 0,
    int32_t stattrack = 0,
    int32_t stickers_0 = 0,
    int32_t stickers_1 = 0,
    int32_t stickers_2 = 0,
    int32_t stickers_3 = 0,
    int32_t stickers_4 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> custom_name = 0,
    uint64_t id = 0) {
  ItemBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_skin_key(skin_key);
  builder_.add_custom_name(custom_name);
  builder_.add_stickers_4(stickers_4);
  builder_.add_stickers_3(stickers_3);
  builder_.add_stickers_2(stickers_2);
  builder_.add_stickers_1(stickers_1);
  builder_.add_stickers_0(stickers_0);
  builder_.add_stattrack(stattrack);
  builder_.add_paint_wear(paint_wear);
  builder_.add_paint_seed(paint_seed);
  builder_.add_path_image(path_image);
  builder_.add_type(type);
  builder_.add_texture_id(texture_id);
  builder_.add_rariry(rariry);
  builder_.add_paint_id(paint_id);
  builder_.add_name(name);
  builder_.add_paint_name(paint_name);
  builder_.add_item_def(item_def);
  builder_.add_is_initilization(is_initilization);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Item> CreateItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item_def = 0,
    const char *paint_name = nullptr,
    const char *name = nullptr,
    uint64_t skin_key = 0,
    int32_t paint_id = 0,
    int32_t rariry = 0,
    int32_t texture_id = 0,
    int32_t type = 0,
    const char *path_image = nullptr,
    bool is_initilization = false,
    int32_t paint_seed = 0,
    int32_t paint_wear = 0,
    int32_t stattrack = 0,
    int32_t stickers_0 = 0,
    int32_t stickers_1 = 0,
    int32_t stickers_2 = 0,
    int32_t stickers_3 = 0,
    int32_t stickers_4 = 0,
    const char *custom_name = nullptr,
    uint64_t id = 0) {
  auto paint_name__ = paint_name ? _fbb.CreateString(paint_name) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto path_image__ = path_image ? _fbb.CreateString(path_image) : 0;
  auto custom_name__ = custom_name ? _fbb.CreateString(custom_name) : 0;
  return CreateItem(
      _fbb,
      item_def,
      paint_name__,
      name__,
      skin_key,
      paint_id,
      rariry,
      texture_id,
      type,
      path_image__,
      is_initilization,
      paint_seed,
      paint_wear,
      stattrack,
      stickers_0,
      stickers_1,
      stickers_2,
      stickers_3,
      stickers_4,
      custom_name__,
      id);
}

::flatbuffers::Offset<Item> CreateItem(::flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConfigSettingsT : public ::flatbuffers::NativeTable {
  typedef ConfigSettings TableType;
  bool m_verify = false;
  std::unique_ptr<antiaimT> m_antiaim{};
  std::vector<std::unique_ptr<legit_settingsT>> m_legit_weapons{};
  std::unique_ptr<rage_global_settingsT> m_rage_global_settings{};
  std::vector<std::unique_ptr<rage_settingsT>> m_rage_weapons{};
  std::unique_ptr<visualsT> m_visuals{};
  std::unique_ptr<miscT> m_misc{};
  std::vector<std::unique_ptr<Hotkey_T>> m_binds{};
  std::vector<std::unique_ptr<InventoryT>> m_equip_inventory{};
  std::vector<std::unique_ptr<ItemT>> m_added_item{};
  ConfigSettingsT() = default;
  ConfigSettingsT(const ConfigSettingsT &o);
  ConfigSettingsT(ConfigSettingsT&&) FLATBUFFERS_NOEXCEPT = default;
  ConfigSettingsT &operator=(ConfigSettingsT o) FLATBUFFERS_NOEXCEPT;
};

struct ConfigSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigSettingsT NativeTableType;
  typedef ConfigSettingsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConfigSettingsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_VERIFY = 4,
    VT_M_ANTIAIM = 6,
    VT_M_LEGIT_WEAPONS = 8,
    VT_M_RAGE_GLOBAL_SETTINGS = 10,
    VT_M_RAGE_WEAPONS = 12,
    VT_M_VISUALS = 14,
    VT_M_MISC = 16,
    VT_M_BINDS = 18,
    VT_M_EQUIP_INVENTORY = 20,
    VT_M_ADDED_ITEM = 22
  };
  bool m_verify() const {
    return GetField<uint8_t>(VT_M_VERIFY, 0) != 0;
  }
  bool mutate_m_verify(bool _m_verify = 0) {
    return SetField<uint8_t>(VT_M_VERIFY, static_cast<uint8_t>(_m_verify), 0);
  }
  const antiaim *m_antiaim() const {
    return GetPointer<const antiaim *>(VT_M_ANTIAIM);
  }
  antiaim *mutable_m_antiaim() {
    return GetPointer<antiaim *>(VT_M_ANTIAIM);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<legit_settings>> *m_legit_weapons() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<legit_settings>> *>(VT_M_LEGIT_WEAPONS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<legit_settings>> *mutable_m_legit_weapons() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<legit_settings>> *>(VT_M_LEGIT_WEAPONS);
  }
  const rage_global_settings *m_rage_global_settings() const {
    return GetPointer<const rage_global_settings *>(VT_M_RAGE_GLOBAL_SETTINGS);
  }
  rage_global_settings *mutable_m_rage_global_settings() {
    return GetPointer<rage_global_settings *>(VT_M_RAGE_GLOBAL_SETTINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<rage_settings>> *m_rage_weapons() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<rage_settings>> *>(VT_M_RAGE_WEAPONS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<rage_settings>> *mutable_m_rage_weapons() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<rage_settings>> *>(VT_M_RAGE_WEAPONS);
  }
  const visuals *m_visuals() const {
    return GetPointer<const visuals *>(VT_M_VISUALS);
  }
  visuals *mutable_m_visuals() {
    return GetPointer<visuals *>(VT_M_VISUALS);
  }
  const misc *m_misc() const {
    return GetPointer<const misc *>(VT_M_MISC);
  }
  misc *mutable_m_misc() {
    return GetPointer<misc *>(VT_M_MISC);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Hotkey_>> *m_binds() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Hotkey_>> *>(VT_M_BINDS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<Hotkey_>> *mutable_m_binds() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Hotkey_>> *>(VT_M_BINDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Inventory>> *m_equip_inventory() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Inventory>> *>(VT_M_EQUIP_INVENTORY);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<Inventory>> *mutable_m_equip_inventory() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Inventory>> *>(VT_M_EQUIP_INVENTORY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Item>> *m_added_item() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Item>> *>(VT_M_ADDED_ITEM);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<Item>> *mutable_m_added_item() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Item>> *>(VT_M_ADDED_ITEM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_M_VERIFY, 1) &&
           VerifyOffset(verifier, VT_M_ANTIAIM) &&
           verifier.VerifyTable(m_antiaim()) &&
           VerifyOffset(verifier, VT_M_LEGIT_WEAPONS) &&
           verifier.VerifyVector(m_legit_weapons()) &&
           verifier.VerifyVectorOfTables(m_legit_weapons()) &&
           VerifyOffset(verifier, VT_M_RAGE_GLOBAL_SETTINGS) &&
           verifier.VerifyTable(m_rage_global_settings()) &&
           VerifyOffset(verifier, VT_M_RAGE_WEAPONS) &&
           verifier.VerifyVector(m_rage_weapons()) &&
           verifier.VerifyVectorOfTables(m_rage_weapons()) &&
           VerifyOffset(verifier, VT_M_VISUALS) &&
           verifier.VerifyTable(m_visuals()) &&
           VerifyOffset(verifier, VT_M_MISC) &&
           verifier.VerifyTable(m_misc()) &&
           VerifyOffset(verifier, VT_M_BINDS) &&
           verifier.VerifyVector(m_binds()) &&
           verifier.VerifyVectorOfTables(m_binds()) &&
           VerifyOffset(verifier, VT_M_EQUIP_INVENTORY) &&
           verifier.VerifyVector(m_equip_inventory()) &&
           verifier.VerifyVectorOfTables(m_equip_inventory()) &&
           VerifyOffset(verifier, VT_M_ADDED_ITEM) &&
           verifier.VerifyVector(m_added_item()) &&
           verifier.VerifyVectorOfTables(m_added_item()) &&
           verifier.EndTable();
  }
  ConfigSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConfigSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ConfigSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConfigSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConfigSettingsBuilder {
  typedef ConfigSettings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_m_verify(bool m_verify) {
    fbb_.AddElement<uint8_t>(ConfigSettings::VT_M_VERIFY, static_cast<uint8_t>(m_verify), 0);
  }
  void add_m_antiaim(::flatbuffers::Offset<antiaim> m_antiaim) {
    fbb_.AddOffset(ConfigSettings::VT_M_ANTIAIM, m_antiaim);
  }
  void add_m_legit_weapons(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<legit_settings>>> m_legit_weapons) {
    fbb_.AddOffset(ConfigSettings::VT_M_LEGIT_WEAPONS, m_legit_weapons);
  }
  void add_m_rage_global_settings(::flatbuffers::Offset<rage_global_settings> m_rage_global_settings) {
    fbb_.AddOffset(ConfigSettings::VT_M_RAGE_GLOBAL_SETTINGS, m_rage_global_settings);
  }
  void add_m_rage_weapons(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rage_settings>>> m_rage_weapons) {
    fbb_.AddOffset(ConfigSettings::VT_M_RAGE_WEAPONS, m_rage_weapons);
  }
  void add_m_visuals(::flatbuffers::Offset<visuals> m_visuals) {
    fbb_.AddOffset(ConfigSettings::VT_M_VISUALS, m_visuals);
  }
  void add_m_misc(::flatbuffers::Offset<misc> m_misc) {
    fbb_.AddOffset(ConfigSettings::VT_M_MISC, m_misc);
  }
  void add_m_binds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Hotkey_>>> m_binds) {
    fbb_.AddOffset(ConfigSettings::VT_M_BINDS, m_binds);
  }
  void add_m_equip_inventory(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Inventory>>> m_equip_inventory) {
    fbb_.AddOffset(ConfigSettings::VT_M_EQUIP_INVENTORY, m_equip_inventory);
  }
  void add_m_added_item(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Item>>> m_added_item) {
    fbb_.AddOffset(ConfigSettings::VT_M_ADDED_ITEM, m_added_item);
  }
  explicit ConfigSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigSettings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigSettings> CreateConfigSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool m_verify = false,
    ::flatbuffers::Offset<antiaim> m_antiaim = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<legit_settings>>> m_legit_weapons = 0,
    ::flatbuffers::Offset<rage_global_settings> m_rage_global_settings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rage_settings>>> m_rage_weapons = 0,
    ::flatbuffers::Offset<visuals> m_visuals = 0,
    ::flatbuffers::Offset<misc> m_misc = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Hotkey_>>> m_binds = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Inventory>>> m_equip_inventory = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Item>>> m_added_item = 0) {
  ConfigSettingsBuilder builder_(_fbb);
  builder_.add_m_added_item(m_added_item);
  builder_.add_m_equip_inventory(m_equip_inventory);
  builder_.add_m_binds(m_binds);
  builder_.add_m_misc(m_misc);
  builder_.add_m_visuals(m_visuals);
  builder_.add_m_rage_weapons(m_rage_weapons);
  builder_.add_m_rage_global_settings(m_rage_global_settings);
  builder_.add_m_legit_weapons(m_legit_weapons);
  builder_.add_m_antiaim(m_antiaim);
  builder_.add_m_verify(m_verify);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConfigSettings> CreateConfigSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool m_verify = false,
    ::flatbuffers::Offset<antiaim> m_antiaim = 0,
    const std::vector<::flatbuffers::Offset<legit_settings>> *m_legit_weapons = nullptr,
    ::flatbuffers::Offset<rage_global_settings> m_rage_global_settings = 0,
    const std::vector<::flatbuffers::Offset<rage_settings>> *m_rage_weapons = nullptr,
    ::flatbuffers::Offset<visuals> m_visuals = 0,
    ::flatbuffers::Offset<misc> m_misc = 0,
    const std::vector<::flatbuffers::Offset<Hotkey_>> *m_binds = nullptr,
    const std::vector<::flatbuffers::Offset<Inventory>> *m_equip_inventory = nullptr,
    const std::vector<::flatbuffers::Offset<Item>> *m_added_item = nullptr) {
  auto m_legit_weapons__ = m_legit_weapons ? _fbb.CreateVector<::flatbuffers::Offset<legit_settings>>(*m_legit_weapons) : 0;
  auto m_rage_weapons__ = m_rage_weapons ? _fbb.CreateVector<::flatbuffers::Offset<rage_settings>>(*m_rage_weapons) : 0;
  auto m_binds__ = m_binds ? _fbb.CreateVector<::flatbuffers::Offset<Hotkey_>>(*m_binds) : 0;
  auto m_equip_inventory__ = m_equip_inventory ? _fbb.CreateVector<::flatbuffers::Offset<Inventory>>(*m_equip_inventory) : 0;
  auto m_added_item__ = m_added_item ? _fbb.CreateVector<::flatbuffers::Offset<Item>>(*m_added_item) : 0;
  return CreateConfigSettings(
      _fbb,
      m_verify,
      m_antiaim,
      m_legit_weapons__,
      m_rage_global_settings,
      m_rage_weapons__,
      m_visuals,
      m_misc,
      m_binds__,
      m_equip_inventory__,
      m_added_item__);
}

::flatbuffers::Offset<ConfigSettings> CreateConfigSettings(::flatbuffers::FlatBufferBuilder &_fbb, const ConfigSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const Hotkey_T &lhs, const Hotkey_T &rhs) {
  return
      (lhs.hash == rhs.hash) &&
      (lhs.key == rhs.key) &&
      (lhs.mode == rhs.mode) &&
      (lhs.visible == rhs.visible) &&
      (lhs.type == rhs.type) &&
      (lhs.name_visual == rhs.name_visual) &&
      (lhs.name == rhs.name) &&
      (lhs.value == rhs.value);
}

inline bool operator!=(const Hotkey_T &lhs, const Hotkey_T &rhs) {
    return !(lhs == rhs);
}


inline Hotkey_T *Hotkey_::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Hotkey_T>(new Hotkey_T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Hotkey_::UnPackTo(Hotkey_T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hash(); _o->hash = _e; }
  { auto _e = key(); _o->key = _e; }
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = visible(); _o->visible = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = name_visual(); if (_e) { _o->name_visual.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->name_visual[_i] = _e->Get(_i)->str(); } } else { _o->name_visual.resize(0); } }
  { auto _e = name(); if (_e) { _o->name.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->name[_i] = _e->Get(_i)->str(); } } else { _o->name.resize(0); } }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->value[_i] = _e->Get(_i); } } else { _o->value.resize(0); } }
}

inline ::flatbuffers::Offset<Hotkey_> Hotkey_::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Hotkey_T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHotkey_(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Hotkey_> CreateHotkey_(::flatbuffers::FlatBufferBuilder &_fbb, const Hotkey_T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Hotkey_T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hash = _o->hash;
  auto _key = _o->key;
  auto _mode = _o->mode;
  auto _visible = _o->visible;
  auto _type = _o->type;
  auto _name_visual = _o->name_visual.size() ? _fbb.CreateVectorOfStrings(_o->name_visual) : 0;
  auto _name = _o->name.size() ? _fbb.CreateVectorOfStrings(_o->name) : 0;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return CreateHotkey_(
      _fbb,
      _hash,
      _key,
      _mode,
      _visible,
      _type,
      _name_visual,
      _name,
      _value);
}


inline bool operator==(const InventoryT &lhs, const InventoryT &rhs) {
  return
      (lhs.item_id == rhs.item_id) &&
      (lhs.team == rhs.team) &&
      (lhs.slot == rhs.slot);
}

inline bool operator!=(const InventoryT &lhs, const InventoryT &rhs) {
    return !(lhs == rhs);
}


inline InventoryT *Inventory::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InventoryT>(new InventoryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Inventory::UnPackTo(InventoryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item_id(); _o->item_id = _e; }
  { auto _e = team(); _o->team = _e; }
  { auto _e = slot(); _o->slot = _e; }
}

inline ::flatbuffers::Offset<Inventory> Inventory::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InventoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInventory(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Inventory> CreateInventory(::flatbuffers::FlatBufferBuilder &_fbb, const InventoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InventoryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item_id = _o->item_id;
  auto _team = _o->team;
  auto _slot = _o->slot;
  return CreateInventory(
      _fbb,
      _item_id,
      _team,
      _slot);
}


inline bool operator==(const ItemT &lhs, const ItemT &rhs) {
  return
      (lhs.item_def == rhs.item_def) &&
      (lhs.paint_name == rhs.paint_name) &&
      (lhs.name == rhs.name) &&
      (lhs.skin_key == rhs.skin_key) &&
      (lhs.paint_id == rhs.paint_id) &&
      (lhs.rariry == rhs.rariry) &&
      (lhs.texture_id == rhs.texture_id) &&
      (lhs.type == rhs.type) &&
      (lhs.path_image == rhs.path_image) &&
      (lhs.is_initilization == rhs.is_initilization) &&
      (lhs.paint_seed == rhs.paint_seed) &&
      (lhs.paint_wear == rhs.paint_wear) &&
      (lhs.stattrack == rhs.stattrack) &&
      (lhs.stickers_0 == rhs.stickers_0) &&
      (lhs.stickers_1 == rhs.stickers_1) &&
      (lhs.stickers_2 == rhs.stickers_2) &&
      (lhs.stickers_3 == rhs.stickers_3) &&
      (lhs.stickers_4 == rhs.stickers_4) &&
      (lhs.custom_name == rhs.custom_name) &&
      (lhs.id == rhs.id);
}

inline bool operator!=(const ItemT &lhs, const ItemT &rhs) {
    return !(lhs == rhs);
}


inline ItemT *Item::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ItemT>(new ItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Item::UnPackTo(ItemT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item_def(); _o->item_def = _e; }
  { auto _e = paint_name(); if (_e) _o->paint_name = _e->str(); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = skin_key(); _o->skin_key = _e; }
  { auto _e = paint_id(); _o->paint_id = _e; }
  { auto _e = rariry(); _o->rariry = _e; }
  { auto _e = texture_id(); _o->texture_id = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = path_image(); if (_e) _o->path_image = _e->str(); }
  { auto _e = is_initilization(); _o->is_initilization = _e; }
  { auto _e = paint_seed(); _o->paint_seed = _e; }
  { auto _e = paint_wear(); _o->paint_wear = _e; }
  { auto _e = stattrack(); _o->stattrack = _e; }
  { auto _e = stickers_0(); _o->stickers_0 = _e; }
  { auto _e = stickers_1(); _o->stickers_1 = _e; }
  { auto _e = stickers_2(); _o->stickers_2 = _e; }
  { auto _e = stickers_3(); _o->stickers_3 = _e; }
  { auto _e = stickers_4(); _o->stickers_4 = _e; }
  { auto _e = custom_name(); if (_e) _o->custom_name = _e->str(); }
  { auto _e = id(); _o->id = _e; }
}

inline ::flatbuffers::Offset<Item> Item::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItem(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Item> CreateItem(::flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ItemT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item_def = _o->item_def;
  auto _paint_name = _o->paint_name.empty() ? 0 : _fbb.CreateString(_o->paint_name);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _skin_key = _o->skin_key;
  auto _paint_id = _o->paint_id;
  auto _rariry = _o->rariry;
  auto _texture_id = _o->texture_id;
  auto _type = _o->type;
  auto _path_image = _o->path_image.empty() ? 0 : _fbb.CreateString(_o->path_image);
  auto _is_initilization = _o->is_initilization;
  auto _paint_seed = _o->paint_seed;
  auto _paint_wear = _o->paint_wear;
  auto _stattrack = _o->stattrack;
  auto _stickers_0 = _o->stickers_0;
  auto _stickers_1 = _o->stickers_1;
  auto _stickers_2 = _o->stickers_2;
  auto _stickers_3 = _o->stickers_3;
  auto _stickers_4 = _o->stickers_4;
  auto _custom_name = _o->custom_name.empty() ? 0 : _fbb.CreateString(_o->custom_name);
  auto _id = _o->id;
  return CreateItem(
      _fbb,
      _item_def,
      _paint_name,
      _name,
      _skin_key,
      _paint_id,
      _rariry,
      _texture_id,
      _type,
      _path_image,
      _is_initilization,
      _paint_seed,
      _paint_wear,
      _stattrack,
      _stickers_0,
      _stickers_1,
      _stickers_2,
      _stickers_3,
      _stickers_4,
      _custom_name,
      _id);
}


inline bool operator==(const ConfigSettingsT &lhs, const ConfigSettingsT &rhs) {
  return
      (lhs.m_verify == rhs.m_verify) &&
      ((lhs.m_antiaim == rhs.m_antiaim) || (lhs.m_antiaim && rhs.m_antiaim && *lhs.m_antiaim == *rhs.m_antiaim)) &&
      (lhs.m_legit_weapons.size() == rhs.m_legit_weapons.size() && std::equal(lhs.m_legit_weapons.cbegin(), lhs.m_legit_weapons.cend(), rhs.m_legit_weapons.cbegin(), [](std::unique_ptr<legit_settingsT> const &a, std::unique_ptr<legit_settingsT> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      ((lhs.m_rage_global_settings == rhs.m_rage_global_settings) || (lhs.m_rage_global_settings && rhs.m_rage_global_settings && *lhs.m_rage_global_settings == *rhs.m_rage_global_settings)) &&
      (lhs.m_rage_weapons.size() == rhs.m_rage_weapons.size() && std::equal(lhs.m_rage_weapons.cbegin(), lhs.m_rage_weapons.cend(), rhs.m_rage_weapons.cbegin(), [](std::unique_ptr<rage_settingsT> const &a, std::unique_ptr<rage_settingsT> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      ((lhs.m_visuals == rhs.m_visuals) || (lhs.m_visuals && rhs.m_visuals && *lhs.m_visuals == *rhs.m_visuals)) &&
      ((lhs.m_misc == rhs.m_misc) || (lhs.m_misc && rhs.m_misc && *lhs.m_misc == *rhs.m_misc)) &&
      (lhs.m_binds.size() == rhs.m_binds.size() && std::equal(lhs.m_binds.cbegin(), lhs.m_binds.cend(), rhs.m_binds.cbegin(), [](std::unique_ptr<Hotkey_T> const &a, std::unique_ptr<Hotkey_T> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.m_equip_inventory.size() == rhs.m_equip_inventory.size() && std::equal(lhs.m_equip_inventory.cbegin(), lhs.m_equip_inventory.cend(), rhs.m_equip_inventory.cbegin(), [](std::unique_ptr<InventoryT> const &a, std::unique_ptr<InventoryT> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.m_added_item.size() == rhs.m_added_item.size() && std::equal(lhs.m_added_item.cbegin(), lhs.m_added_item.cend(), rhs.m_added_item.cbegin(), [](std::unique_ptr<ItemT> const &a, std::unique_ptr<ItemT> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const ConfigSettingsT &lhs, const ConfigSettingsT &rhs) {
    return !(lhs == rhs);
}


inline ConfigSettingsT::ConfigSettingsT(const ConfigSettingsT &o)
      : m_verify(o.m_verify),
        m_antiaim((o.m_antiaim) ? new antiaimT(*o.m_antiaim) : nullptr),
        m_rage_global_settings((o.m_rage_global_settings) ? new rage_global_settingsT(*o.m_rage_global_settings) : nullptr),
        m_visuals((o.m_visuals) ? new visualsT(*o.m_visuals) : nullptr),
        m_misc((o.m_misc) ? new miscT(*o.m_misc) : nullptr) {
  m_legit_weapons.reserve(o.m_legit_weapons.size());
  for (const auto &m_legit_weapons_ : o.m_legit_weapons) { m_legit_weapons.emplace_back((m_legit_weapons_) ? new legit_settingsT(*m_legit_weapons_) : nullptr); }
  m_rage_weapons.reserve(o.m_rage_weapons.size());
  for (const auto &m_rage_weapons_ : o.m_rage_weapons) { m_rage_weapons.emplace_back((m_rage_weapons_) ? new rage_settingsT(*m_rage_weapons_) : nullptr); }
  m_binds.reserve(o.m_binds.size());
  for (const auto &m_binds_ : o.m_binds) { m_binds.emplace_back((m_binds_) ? new Hotkey_T(*m_binds_) : nullptr); }
  m_equip_inventory.reserve(o.m_equip_inventory.size());
  for (const auto &m_equip_inventory_ : o.m_equip_inventory) { m_equip_inventory.emplace_back((m_equip_inventory_) ? new InventoryT(*m_equip_inventory_) : nullptr); }
  m_added_item.reserve(o.m_added_item.size());
  for (const auto &m_added_item_ : o.m_added_item) { m_added_item.emplace_back((m_added_item_) ? new ItemT(*m_added_item_) : nullptr); }
}

inline ConfigSettingsT &ConfigSettingsT::operator=(ConfigSettingsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(m_verify, o.m_verify);
  std::swap(m_antiaim, o.m_antiaim);
  std::swap(m_legit_weapons, o.m_legit_weapons);
  std::swap(m_rage_global_settings, o.m_rage_global_settings);
  std::swap(m_rage_weapons, o.m_rage_weapons);
  std::swap(m_visuals, o.m_visuals);
  std::swap(m_misc, o.m_misc);
  std::swap(m_binds, o.m_binds);
  std::swap(m_equip_inventory, o.m_equip_inventory);
  std::swap(m_added_item, o.m_added_item);
  return *this;
}

inline ConfigSettingsT *ConfigSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConfigSettingsT>(new ConfigSettingsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConfigSettings::UnPackTo(ConfigSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = m_verify(); _o->m_verify = _e; }
  { auto _e = m_antiaim(); if (_e) { if(_o->m_antiaim) { _e->UnPackTo(_o->m_antiaim.get(), _resolver); } else { _o->m_antiaim = std::unique_ptr<antiaimT>(_e->UnPack(_resolver)); } } else if (_o->m_antiaim) { _o->m_antiaim.reset(); } }
  { auto _e = m_legit_weapons(); if (_e) { _o->m_legit_weapons.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->m_legit_weapons[_i]) { _e->Get(_i)->UnPackTo(_o->m_legit_weapons[_i].get(), _resolver); } else { _o->m_legit_weapons[_i] = std::unique_ptr<legit_settingsT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->m_legit_weapons.resize(0); } }
  { auto _e = m_rage_global_settings(); if (_e) { if(_o->m_rage_global_settings) { _e->UnPackTo(_o->m_rage_global_settings.get(), _resolver); } else { _o->m_rage_global_settings = std::unique_ptr<rage_global_settingsT>(_e->UnPack(_resolver)); } } else if (_o->m_rage_global_settings) { _o->m_rage_global_settings.reset(); } }
  { auto _e = m_rage_weapons(); if (_e) { _o->m_rage_weapons.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->m_rage_weapons[_i]) { _e->Get(_i)->UnPackTo(_o->m_rage_weapons[_i].get(), _resolver); } else { _o->m_rage_weapons[_i] = std::unique_ptr<rage_settingsT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->m_rage_weapons.resize(0); } }
  { auto _e = m_visuals(); if (_e) { if(_o->m_visuals) { _e->UnPackTo(_o->m_visuals.get(), _resolver); } else { _o->m_visuals = std::unique_ptr<visualsT>(_e->UnPack(_resolver)); } } else if (_o->m_visuals) { _o->m_visuals.reset(); } }
  { auto _e = m_misc(); if (_e) { if(_o->m_misc) { _e->UnPackTo(_o->m_misc.get(), _resolver); } else { _o->m_misc = std::unique_ptr<miscT>(_e->UnPack(_resolver)); } } else if (_o->m_misc) { _o->m_misc.reset(); } }
  { auto _e = m_binds(); if (_e) { _o->m_binds.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->m_binds[_i]) { _e->Get(_i)->UnPackTo(_o->m_binds[_i].get(), _resolver); } else { _o->m_binds[_i] = std::unique_ptr<Hotkey_T>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->m_binds.resize(0); } }
  { auto _e = m_equip_inventory(); if (_e) { _o->m_equip_inventory.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->m_equip_inventory[_i]) { _e->Get(_i)->UnPackTo(_o->m_equip_inventory[_i].get(), _resolver); } else { _o->m_equip_inventory[_i] = std::unique_ptr<InventoryT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->m_equip_inventory.resize(0); } }
  { auto _e = m_added_item(); if (_e) { _o->m_added_item.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->m_added_item[_i]) { _e->Get(_i)->UnPackTo(_o->m_added_item[_i].get(), _resolver); } else { _o->m_added_item[_i] = std::unique_ptr<ItemT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->m_added_item.resize(0); } }
}

inline ::flatbuffers::Offset<ConfigSettings> ConfigSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConfigSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConfigSettings(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ConfigSettings> CreateConfigSettings(::flatbuffers::FlatBufferBuilder &_fbb, const ConfigSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConfigSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _m_verify = _o->m_verify;
  auto _m_antiaim = _o->m_antiaim ? Createantiaim(_fbb, _o->m_antiaim.get(), _rehasher) : 0;
  auto _m_legit_weapons = _o->m_legit_weapons.size() ? _fbb.CreateVector<::flatbuffers::Offset<legit_settings>> (_o->m_legit_weapons.size(), [](size_t i, _VectorArgs *__va) { return Createlegit_settings(*__va->__fbb, __va->__o->m_legit_weapons[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _m_rage_global_settings = _o->m_rage_global_settings ? Createrage_global_settings(_fbb, _o->m_rage_global_settings.get(), _rehasher) : 0;
  auto _m_rage_weapons = _o->m_rage_weapons.size() ? _fbb.CreateVector<::flatbuffers::Offset<rage_settings>> (_o->m_rage_weapons.size(), [](size_t i, _VectorArgs *__va) { return Createrage_settings(*__va->__fbb, __va->__o->m_rage_weapons[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _m_visuals = _o->m_visuals ? Createvisuals(_fbb, _o->m_visuals.get(), _rehasher) : 0;
  auto _m_misc = _o->m_misc ? Createmisc(_fbb, _o->m_misc.get(), _rehasher) : 0;
  auto _m_binds = _o->m_binds.size() ? _fbb.CreateVector<::flatbuffers::Offset<Hotkey_>> (_o->m_binds.size(), [](size_t i, _VectorArgs *__va) { return CreateHotkey_(*__va->__fbb, __va->__o->m_binds[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _m_equip_inventory = _o->m_equip_inventory.size() ? _fbb.CreateVector<::flatbuffers::Offset<Inventory>> (_o->m_equip_inventory.size(), [](size_t i, _VectorArgs *__va) { return CreateInventory(*__va->__fbb, __va->__o->m_equip_inventory[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _m_added_item = _o->m_added_item.size() ? _fbb.CreateVector<::flatbuffers::Offset<Item>> (_o->m_added_item.size(), [](size_t i, _VectorArgs *__va) { return CreateItem(*__va->__fbb, __va->__o->m_added_item[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateConfigSettings(
      _fbb,
      _m_verify,
      _m_antiaim,
      _m_legit_weapons,
      _m_rage_global_settings,
      _m_rage_weapons,
      _m_visuals,
      _m_misc,
      _m_binds,
      _m_equip_inventory,
      _m_added_item);
}

inline const ::flatbuffers::TypeTable *Hotkey_TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_DOUBLE, 1, -1 }
  };
  static const char * const names[] = {
    "hash",
    "key",
    "mode",
    "visible",
    "type",
    "name_visual",
    "name",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *InventoryTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "item_id",
    "team",
    "slot"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ItemTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "item_def",
    "paint_name",
    "name",
    "skin_key",
    "paint_id",
    "rariry",
    "texture_id",
    "type",
    "path_image",
    "is_initilization",
    "paint_seed",
    "paint_wear",
    "stattrack",
    "stickers_0",
    "stickers_1",
    "stickers_2",
    "stickers_3",
    "stickers_4",
    "custom_name",
    "id"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 20, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ConfigSettingsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 },
    { ::flatbuffers::ET_SEQUENCE, 0, 5 },
    { ::flatbuffers::ET_SEQUENCE, 1, 6 },
    { ::flatbuffers::ET_SEQUENCE, 1, 7 },
    { ::flatbuffers::ET_SEQUENCE, 1, 8 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    antiaimTypeTable,
    legit_settingsTypeTable,
    rage_global_settingsTypeTable,
    rage_settingsTypeTable,
    visualsTypeTable,
    miscTypeTable,
    Hotkey_TypeTable,
    InventoryTypeTable,
    ItemTypeTable
  };
  static const char * const names[] = {
    "m_verify",
    "m_antiaim",
    "m_legit_weapons",
    "m_rage_global_settings",
    "m_rage_weapons",
    "m_visuals",
    "m_misc",
    "m_binds",
    "m_equip_inventory",
    "m_added_item"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_CONFIGTABLE_H_
