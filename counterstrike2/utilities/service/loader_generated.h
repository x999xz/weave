// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LOADER_H_
#define FLATBUFFERS_GENERATED_LOADER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct LoaderUser;
struct LoaderUserBuilder;

struct Build;
struct BuildBuilder;

struct Subscription;
struct SubscriptionBuilder;

struct Loader;
struct LoaderBuilder;

struct LoaderUser FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoaderUserBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERNAME = 4,
    VT_PREFIX = 6,
    VT_ID = 8
  };
  const ::flatbuffers::String *username() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USERNAME);
  }
  const ::flatbuffers::String *prefix() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PREFIX);
  }
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USERNAME) &&
           verifier.VerifyString(username()) &&
           VerifyOffset(verifier, VT_PREFIX) &&
           verifier.VerifyString(prefix()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

struct LoaderUserBuilder {
  typedef LoaderUser Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_username(::flatbuffers::Offset<::flatbuffers::String> username) {
    fbb_.AddOffset(LoaderUser::VT_USERNAME, username);
  }
  void add_prefix(::flatbuffers::Offset<::flatbuffers::String> prefix) {
    fbb_.AddOffset(LoaderUser::VT_PREFIX, prefix);
  }
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(LoaderUser::VT_ID, id);
  }
  explicit LoaderUserBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoaderUser> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoaderUser>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LoaderUser> CreateLoaderUser(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> username = 0,
    ::flatbuffers::Offset<::flatbuffers::String> prefix = 0,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  LoaderUserBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_prefix(prefix);
  builder_.add_username(username);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LoaderUser> CreateLoaderUserDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *username = nullptr,
    const char *prefix = nullptr,
    const char *id = nullptr) {
  auto username__ = username ? _fbb.CreateString(username) : 0;
  auto prefix__ = prefix ? _fbb.CreateString(prefix) : 0;
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return CreateLoaderUser(
      _fbb,
      username__,
      prefix__,
      id__);
}

struct Build FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BuildBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUILD = 4,
    VT_SUB_TIME = 6,
    VT_PROCESS = 8,
    VT_COMMAND = 10,
    VT_ID = 12
  };
  const ::flatbuffers::String *build() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BUILD);
  }
  uint64_t sub_time() const {
    return GetField<uint64_t>(VT_SUB_TIME, 0);
  }
  const ::flatbuffers::String *process() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROCESS);
  }
  const ::flatbuffers::String *command() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUILD) &&
           verifier.VerifyString(build()) &&
           VerifyField<uint64_t>(verifier, VT_SUB_TIME, 8) &&
           VerifyOffset(verifier, VT_PROCESS) &&
           verifier.VerifyString(process()) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           verifier.EndTable();
  }
};

struct BuildBuilder {
  typedef Build Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_build(::flatbuffers::Offset<::flatbuffers::String> build) {
    fbb_.AddOffset(Build::VT_BUILD, build);
  }
  void add_sub_time(uint64_t sub_time) {
    fbb_.AddElement<uint64_t>(Build::VT_SUB_TIME, sub_time, 0);
  }
  void add_process(::flatbuffers::Offset<::flatbuffers::String> process) {
    fbb_.AddOffset(Build::VT_PROCESS, process);
  }
  void add_command(::flatbuffers::Offset<::flatbuffers::String> command) {
    fbb_.AddOffset(Build::VT_COMMAND, command);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Build::VT_ID, id, 0);
  }
  explicit BuildBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Build> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Build>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Build> CreateBuild(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> build = 0,
    uint64_t sub_time = 0,
    ::flatbuffers::Offset<::flatbuffers::String> process = 0,
    ::flatbuffers::Offset<::flatbuffers::String> command = 0,
    int32_t id = 0) {
  BuildBuilder builder_(_fbb);
  builder_.add_sub_time(sub_time);
  builder_.add_id(id);
  builder_.add_command(command);
  builder_.add_process(process);
  builder_.add_build(build);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Build> CreateBuildDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *build = nullptr,
    uint64_t sub_time = 0,
    const char *process = nullptr,
    const char *command = nullptr,
    int32_t id = 0) {
  auto build__ = build ? _fbb.CreateString(build) : 0;
  auto process__ = process ? _fbb.CreateString(process) : 0;
  auto command__ = command ? _fbb.CreateString(command) : 0;
  return CreateBuild(
      _fbb,
      build__,
      sub_time,
      process__,
      command__,
      id);
}

struct Subscription FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubscriptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CS2 = 4,
    VT_DOTA2 = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Build>> *cs2() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Build>> *>(VT_CS2);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Build>> *dota2() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Build>> *>(VT_DOTA2);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CS2) &&
           verifier.VerifyVector(cs2()) &&
           verifier.VerifyVectorOfTables(cs2()) &&
           VerifyOffset(verifier, VT_DOTA2) &&
           verifier.VerifyVector(dota2()) &&
           verifier.VerifyVectorOfTables(dota2()) &&
           verifier.EndTable();
  }
};

struct SubscriptionBuilder {
  typedef Subscription Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cs2(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Build>>> cs2) {
    fbb_.AddOffset(Subscription::VT_CS2, cs2);
  }
  void add_dota2(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Build>>> dota2) {
    fbb_.AddOffset(Subscription::VT_DOTA2, dota2);
  }
  explicit SubscriptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Subscription> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Subscription>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Subscription> CreateSubscription(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Build>>> cs2 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Build>>> dota2 = 0) {
  SubscriptionBuilder builder_(_fbb);
  builder_.add_dota2(dota2);
  builder_.add_cs2(cs2);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Subscription> CreateSubscriptionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Build>> *cs2 = nullptr,
    const std::vector<::flatbuffers::Offset<Build>> *dota2 = nullptr) {
  auto cs2__ = cs2 ? _fbb.CreateVector<::flatbuffers::Offset<Build>>(*cs2) : 0;
  auto dota2__ = dota2 ? _fbb.CreateVector<::flatbuffers::Offset<Build>>(*dota2) : 0;
  return CreateSubscription(
      _fbb,
      cs2__,
      dota2__);
}

struct Loader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER = 4,
    VT_SUB = 6
  };
  const LoaderUser *user() const {
    return GetPointer<const LoaderUser *>(VT_USER);
  }
  const Subscription *sub() const {
    return GetPointer<const Subscription *>(VT_SUB);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyTable(user()) &&
           VerifyOffset(verifier, VT_SUB) &&
           verifier.VerifyTable(sub()) &&
           verifier.EndTable();
  }
};

struct LoaderBuilder {
  typedef Loader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user(::flatbuffers::Offset<LoaderUser> user) {
    fbb_.AddOffset(Loader::VT_USER, user);
  }
  void add_sub(::flatbuffers::Offset<Subscription> sub) {
    fbb_.AddOffset(Loader::VT_SUB, sub);
  }
  explicit LoaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Loader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Loader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Loader> CreateLoader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<LoaderUser> user = 0,
    ::flatbuffers::Offset<Subscription> sub = 0) {
  LoaderBuilder builder_(_fbb);
  builder_.add_sub(sub);
  builder_.add_user(user);
  return builder_.Finish();
}

#endif  // FLATBUFFERS_GENERATED_LOADER_H_
